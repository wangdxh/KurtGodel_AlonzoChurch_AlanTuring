{% macro getkeylist() %}
	{% for item in keyitemlist %}
			{{ item.Field }}
	{% endfor %}	
{% endmacro %}

{% macro getkeyparamlist() %}
	{% for item in keyitemlist %}
			{{ item.Field }} {{ item.GoType }}		
	{% endfor %}
{% endmacro %}

{% macro getkeyparamequallist() %}
	{% for item in keyitemlist %}
			{{ item.Field }} = ?		
	{% endfor %}
{% endmacro %}

{% macro getkeyparamsemiequallist() %}
	{% for item in keyitemlist %}
			{{ item.Field }} = :{{ item.Field }}		
	{% endfor %}
{% endmacro %}





{% macro gettableitemlist() %}
	{% for item in TableInfo.Itemlist %}		
			{{ item.Field }}
	{% endfor %}
{% endmacro %}

{% macro gettableitemlistnoauto() %}
	{% for item in TableInfo.Itemlist %}		
	{% if item.Extra != "auto_increment" %}
		{{ item.Field }}
	{% endif %}
			
	{% endfor %}
{% endmacro %}

{% macro gettableitemlistnoautowithquery() %}
	{% for item in TableInfo.Itemlist %}		
	{% if item.Extra != "auto_increment" %}
		:{{ item.Field }}
	{% endif %}			
	{% endfor %}
{% endmacro %}



{% macro gettableitemsemiquerylist() %}
	{% for item in TableInfo.Itemlist %}
			{{ item.Field }}=:{{ item.Field }}
	{% endfor %}
{% endmacro %}

{% macro getcolumsnotnull(bqueryedcolums=true) %}
	var strcolums []string
	{% if bqueryedcolums %}var queryedcolums []string{% endif %}
	{% for item in TableInfo.Itemlist %}	
		{% if  item.GoType|prefix:"int" || item.GoType|prefix:"float" || item.GoType|prefix:"uint"%}
			if (item.{{item.Field|title}} != 0){								
		{% elif item.GoType == "sql.NullInt64" ||  item.GoType == "sql.NullFloat64" %}
			if val, err := item.{{item.Field|title}}.Value(); err == nil && val != 0 {						
		{% elif item.GoType == "sql.NullString" %} 
			if item.{{item.Field|title}}.Valid && len(item.{{item.Field|title}}.String) > 0 {
		{% elif item.GoType == "string" %}
			if (len(item.{{item.Field|title}}) > 0){
		{% elif item.GoType == "[]byte" %}
			if (item.{{item.Field|title}} != nil && len(item.{{item.Field|title}}) > 0){
		{% elif item.GoType == "time.Time" %}
			if (time.Time{} == item.{{item.Field|title}}){
		{% else %}
			error sble ======== {{item.GoType}}, {{item.Field|title}} 
		{% endif %}
				strcolums = append(strcolums, "{{item.Field}}")
				{% if bqueryedcolums %}queryedcolums = append(queryedcolums, ":{{item.Field}}"){% endif %}
			}
	{% endfor %}
	
	{% if bqueryedcolums %}strcols := strings.Join(strcolums, ",")
	strquerycols := strings.Join(queryedcolums, ","){% endif%}
{% endmacro %}

{% macro getcolupdatepair(sep=",") %}
	var strupdatelist []string
	for _, val := range strcolums {
		strupdatelist = append(strupdatelist, fmt.Sprintf("%s=:%s", val, val))
	}
	strupdate := strings.Join(strupdatelist, "{{sep}}")
{% endmacro %}


// the file is generated by gowalle at {% now "Mon Jan 2 15:04:05 -0700 CST 2006"%}
package {{package}}


import (
	{% for key,name in importmap %}
	"{{key}}" {% endfor %}
	"github.com/jmoiron/sqlx"	
	"strings"
	"fmt"
)



type {{TableInfo.Name|title}} struct {
	{% for item in TableInfo.Itemlist %}
	{{item.Field|title}} {{item.GoType}} `json:"{{item.Field}}" db:"{{item.Field}}" dbtype:"{{item.Type}},{{item.Key}}"` {% endfor %}    
}



{% if keyitemlist|length > 0 %}

// insert delete update select
func DbGet{{TableInfo.Name|title}}by{{getkeylist()|joinlines:""}}(dbx *sqlx.DB, {{getkeyparamlist()|joinlines:", "}}) ({{TableInfo.Name|title}}, error){
	item := {{TableInfo.Name|title}}{}
	err := dbx.Get(&item, "select {{ gettableitemlist()|joinlines:","}} from {{TableInfo.Name}} where {{getkeyparamequallist()|joinlines:" and "}};",
				 {{getkeylist()|joinlines:", "}})
	return item, err
}

func DbDelete{{TableInfo.Name|title}}by{{getkeylist()|joinlines:""}}(dbx *sqlx.DB, {{getkeyparamlist()|joinlines:", "}}) (int, error){
	res, err := dbx.Exec("delete from {{TableInfo.Name}}  where {{getkeyparamequallist()|joinlines:" and "}};",
				 {{getkeylist()|joinlines:", "}})
	if err != nil {
		return 0, err
	}
	nums, err := res.RowsAffected()
	if err != nil {
		return int(nums), err
	}
	return int(nums), err
}

func DbUpdate{{TableInfo.Name|title}}by{{getkeylist()|joinlines:""}}(dbx *sqlx.DB, item *{{TableInfo.Name|title}}) (int, error){
	res, err := dbx.Exec("update {{TableInfo.Name}} set {{gettableitemsemiquerylist()|joinlines:","}} where {{getkeyparamsemiequallist()|joinlines:" and "}};",
				 		item)
	if err != nil {
		return 0, err
	}
	nums, err := res.RowsAffected()
	if err != nil {
		return int(nums), err
	}
	return int(nums), err
}

func DbUpdate{{TableInfo.Name|title}}notnullby{{getkeylist()|joinlines:""}}(dbx *sqlx.DB, item *{{TableInfo.Name|title}}) (int, error){
	{{getcolumsnotnull(false)}}
	{{getcolupdatepair()}}

	res, err := dbx.Exec("update {{TableInfo.Name}} set " + strupdate + "  where {{getkeyparamsemiequallist()|joinlines:" and "}};",
				 		item)
	if err != nil {
		return 0, err
	}
	nums, err := res.RowsAffected()
	if err != nil {
		return int(nums), err
	}
	return int(nums), err
}

{% endif %}

// return last insert id
func DbInsert{{TableInfo.Name|title}}(dbx *sqlx.DB, item *{{TableInfo.Name|title}}) (int, error){
	res, err := dbx.NamedExec("insert into {{TableInfo.Name}}({{gettableitemlistnoauto()|joinlines:","}}) "+
					" values ({{gettableitemlistnoautowithquery()|joinlines:","}})", item)	
	if err != nil {
		return 0, err
	}
	id, err := res.LastInsertId()
	if err != nil {
		return 0, err
	}
	return int(id), err
}


func DbInsert{{TableInfo.Name|title}}List(dbx *sqlx.DB, itemlist []{{TableInfo.Name|title}})(int , error){
	res, err := dbx.NamedExec("insert into {{TableInfo.Name}}({{gettableitemlistnoauto()|joinlines:","}}) "+
					" values ({{gettableitemlistnoautowithquery()|joinlines:","}})", itemlist)
	if err != nil {
		return 0, err
	}
	nums, err := res.RowsAffected()
	if err != nil {
		return int(nums), err
	}
	return int(nums), err
}


// insert table coloumns when the item value is not default type value
func DbInsert{{TableInfo.Name|title}}Whennotnull(dbx *sqlx.DB, item *{{TableInfo.Name|title}}) (int, error){
	{{getcolumsnotnull()}}
	res, err := dbx.NamedExec(fmt.Sprintf("insert into {{TableInfo.Name}}(%s) values (%s)", 
								strcols, strquerycols), item)
	if err != nil {
		return 0, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return 0, err
	}
	return int(id), err
}

func DbInsert{{TableInfo.Name|title}}Whennotnullupdate(dbx *sqlx.DB, item *{{TableInfo.Name|title}}) (int, error){
	{{getcolumsnotnull()}}
	{{getcolupdatepair()}}	
	res, err := dbx.NamedExec(fmt.Sprintf("insert into {{TableInfo.Name}}(%s) values (%s)  on duplicate key update ", 
								strcols, strquerycols, strupdate), item)
	if err != nil {
		return 0, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return 0, err
	}
	return int(id), err	
}

{% comment %}

type Query{{TableInfo.Name|title}} struct {
	{{TableInfo.Name|title}}
	Offset int `form:"offset" db:"offset"`
	Nums   int `form:"nums" db:"nums"`
	Orderby string `form:"orderby"`
	Desc    bool   `form:"desc"`
}

func DbGet{{TableInfo.Name|title}}List(db *sqlx.DB, item Query{{TableInfo.Name|title}}) (nums int, tasks []{{TableInfo.Name|title}}, err error) {
	/*err = IsNormalSqlWord(item.Orderby)
	if err != nil {
		return
	}*/

	tasks = []{{TableInfo.Name|title}}{}
	if query.Nums == 0 || query.Nums > 100 {
		query.Nums = 100
	}	
	{{getcolumsnotnull(false)}}
	{{getcolupdatepair(" and ")}}

	itemquery := []string{"select * from {{TableInfo.Name}}", "", " order by id ", " asc ", "limit ?, ?;"}

	var strwhere string
	if len(strupdate) > 0{
		strwhere = " where " + strupdate
	}
	

	err = db.Get(&nums, "select count(*) from scannertask "+itemquery[1], params...)
	if err != nil {
		return
	}

	if len(query.Orderby) > 0 {
		itemquery[2] = " order by " + query.Orderby + " "
		//params = append(params, query.Orderby)
	}
	if query.Desc {
		itemquery[3] = " desc "
	}

	params = append(params, query.Offset)
	params = append(params, query.Nums)
	fmt.Println(strings.Join(itemquery, " "), params)
	err = db.Select(&tasks, strings.Join(itemquery, "  "), params...)
	return
}
{% endcomment %}