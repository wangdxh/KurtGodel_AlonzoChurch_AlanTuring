// Code generated from ./ASN.g4 by ANTLR 4.7.1. DO NOT EDIT.

package parser // ASN

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 106, 1212,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 7,
	2, 295, 10, 2, 12, 2, 14, 2, 298, 11, 2, 3, 2, 5, 2, 301, 10, 2, 3, 2,
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 3, 3, 3, 5, 3, 313, 10, 3,
	3, 4, 3, 4, 5, 4, 317, 10, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 323, 10, 5,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 332, 10, 6, 3, 7, 5, 7,
	335, 10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 341, 10, 8, 3, 9, 5, 9, 344,
	10, 9, 3, 10, 3, 10, 7, 10, 348, 10, 10, 12, 10, 14, 10, 351, 11, 10, 3,
	11, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 14, 3, 14,
	3, 14, 7, 14, 365, 10, 14, 12, 14, 14, 14, 368, 11, 14, 3, 15, 3, 15, 3,
	15, 5, 15, 373, 10, 15, 3, 16, 3, 16, 7, 16, 377, 10, 16, 12, 16, 14, 16,
	380, 11, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 5, 17, 387, 10, 17, 3,
	18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 395, 10, 18, 3, 18, 3, 18,
	3, 19, 3, 19, 5, 19, 401, 10, 19, 3, 20, 3, 20, 5, 20, 405, 10, 20, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 415, 10, 21,
	5, 21, 417, 10, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 425,
	10, 21, 5, 21, 427, 10, 21, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 7, 23, 434,
	10, 23, 12, 23, 14, 23, 437, 11, 23, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24,
	443, 10, 24, 3, 24, 3, 24, 3, 24, 5, 24, 448, 10, 24, 3, 25, 3, 25, 5,
	25, 452, 10, 25, 3, 26, 3, 26, 3, 26, 7, 26, 457, 10, 26, 12, 26, 14, 26,
	460, 11, 26, 3, 27, 3, 27, 5, 27, 464, 10, 27, 3, 28, 3, 28, 3, 28, 3,
	28, 3, 28, 3, 29, 3, 29, 5, 29, 473, 10, 29, 3, 30, 3, 30, 3, 30, 3, 30,
	5, 30, 479, 10, 30, 3, 30, 3, 30, 5, 30, 483, 10, 30, 3, 30, 3, 30, 3,
	30, 5, 30, 488, 10, 30, 3, 31, 3, 31, 3, 31, 3, 32, 3, 32, 3, 32, 3, 32,
	3, 32, 5, 32, 498, 10, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 505,
	10, 32, 5, 32, 507, 10, 32, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33, 513, 10,
	33, 12, 33, 14, 33, 516, 11, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 5,
	34, 523, 10, 34, 3, 34, 3, 34, 3, 35, 3, 35, 5, 35, 529, 10, 35, 3, 36,
	3, 36, 5, 36, 533, 10, 36, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 5, 38, 540,
	10, 38, 3, 39, 3, 39, 5, 39, 544, 10, 39, 3, 39, 3, 39, 3, 39, 5, 39, 549,
	10, 39, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42,
	3, 42, 3, 42, 7, 42, 562, 10, 42, 12, 42, 14, 42, 565, 11, 42, 3, 42, 3,
	42, 5, 42, 569, 10, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 6, 44,
	577, 10, 44, 13, 44, 14, 44, 578, 3, 44, 3, 44, 3, 45, 3, 45, 5, 45, 585,
	10, 45, 3, 46, 3, 46, 6, 46, 589, 10, 46, 13, 46, 14, 46, 590, 3, 46, 3,
	46, 3, 47, 3, 47, 5, 47, 597, 10, 47, 3, 48, 3, 48, 3, 49, 3, 49, 3, 49,
	3, 50, 3, 50, 3, 50, 5, 50, 607, 10, 50, 3, 50, 3, 50, 5, 50, 611, 10,
	50, 3, 50, 5, 50, 614, 10, 50, 3, 50, 5, 50, 617, 10, 50, 5, 50, 619, 10,
	50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 626, 10, 50, 5, 50, 628,
	10, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 635, 10, 50, 5, 50, 637,
	10, 50, 5, 50, 639, 10, 50, 3, 51, 3, 51, 3, 51, 5, 51, 644, 10, 51, 3,
	52, 3, 52, 3, 52, 5, 52, 649, 10, 52, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53,
	655, 10, 53, 3, 53, 5, 53, 658, 10, 53, 3, 54, 3, 54, 3, 54, 5, 54, 663,
	10, 54, 3, 55, 3, 55, 3, 55, 3, 55, 5, 55, 669, 10, 55, 3, 56, 3, 56, 3,
	56, 3, 56, 5, 56, 675, 10, 56, 3, 57, 3, 57, 3, 57, 5, 57, 680, 10, 57,
	3, 58, 3, 58, 5, 58, 684, 10, 58, 3, 59, 3, 59, 3, 59, 3, 60, 3, 60, 5,
	60, 691, 10, 60, 3, 61, 3, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 62,
	3, 62, 5, 62, 702, 10, 62, 5, 62, 704, 10, 62, 3, 62, 3, 62, 3, 62, 5,
	62, 709, 10, 62, 5, 62, 711, 10, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63,
	3, 63, 7, 63, 719, 10, 63, 12, 63, 14, 63, 722, 11, 63, 3, 64, 3, 64, 3,
	64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 733, 10, 65, 5, 65,
	735, 10, 65, 3, 66, 3, 66, 3, 67, 3, 67, 3, 68, 3, 68, 3, 68, 5, 68, 744,
	10, 68, 3, 69, 3, 69, 3, 69, 3, 69, 7, 69, 750, 10, 69, 12, 69, 14, 69,
	753, 11, 69, 3, 70, 3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 3, 71, 7, 71, 762,
	10, 71, 12, 71, 14, 71, 765, 11, 71, 3, 72, 3, 72, 3, 73, 3, 73, 3, 74,
	3, 74, 3, 75, 3, 75, 5, 75, 775, 10, 75, 3, 76, 3, 76, 5, 76, 779, 10,
	76, 3, 77, 3, 77, 5, 77, 783, 10, 77, 3, 77, 5, 77, 786, 10, 77, 3, 77,
	3, 77, 5, 77, 790, 10, 77, 3, 77, 3, 77, 5, 77, 794, 10, 77, 3, 77, 3,
	77, 3, 77, 3, 77, 5, 77, 800, 10, 77, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78,
	806, 10, 78, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 812, 10, 79, 3, 80, 3,
	80, 3, 80, 5, 80, 817, 10, 80, 3, 81, 3, 81, 3, 81, 3, 81, 5, 81, 823,
	10, 81, 3, 82, 3, 82, 3, 82, 5, 82, 828, 10, 82, 3, 83, 3, 83, 3, 83, 3,
	84, 3, 84, 3, 84, 3, 84, 3, 85, 3, 85, 5, 85, 839, 10, 85, 3, 85, 7, 85,
	842, 10, 85, 12, 85, 14, 85, 845, 11, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3,
	86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 5, 86, 858, 10, 86, 3, 87,
	3, 87, 3, 87, 3, 87, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88, 870,
	10, 88, 3, 88, 3, 88, 3, 89, 3, 89, 3, 89, 5, 89, 877, 10, 89, 3, 89, 3,
	89, 3, 89, 5, 89, 882, 10, 89, 3, 90, 3, 90, 3, 91, 3, 91, 3, 91, 5, 91,
	889, 10, 91, 3, 91, 5, 91, 892, 10, 91, 3, 92, 3, 92, 3, 92, 5, 92, 897,
	10, 92, 3, 92, 3, 92, 3, 93, 3, 93, 5, 93, 903, 10, 93, 3, 94, 3, 94, 3,
	94, 3, 94, 3, 94, 3, 94, 7, 94, 911, 10, 94, 12, 94, 14, 94, 914, 11, 94,
	3, 94, 3, 94, 3, 95, 3, 95, 3, 95, 5, 95, 921, 10, 95, 3, 96, 3, 96, 3,
	96, 3, 96, 3, 96, 3, 96, 5, 96, 929, 10, 96, 3, 97, 3, 97, 3, 98, 3, 98,
	3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3,
	99, 5, 99, 946, 10, 99, 3, 100, 3, 100, 3, 101, 3, 101, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 102, 3, 102, 5, 102, 958, 10, 102, 3, 103, 3, 103, 3,
	103, 3, 103, 3, 104, 3, 104, 7, 104, 966, 10, 104, 12, 104, 14, 104, 969,
	11, 104, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 5, 105, 976, 10, 105,
	3, 105, 5, 105, 979, 10, 105, 3, 105, 5, 105, 982, 10, 105, 3, 106, 3,
	106, 5, 106, 986, 10, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 108, 3, 108,
	3, 109, 5, 109, 995, 10, 109, 3, 109, 3, 109, 3, 110, 3, 110, 3, 110, 3,
	110, 3, 110, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 5, 111, 1010,
	10, 111, 3, 112, 3, 112, 5, 112, 1014, 10, 112, 3, 113, 3, 113, 3, 113,
	7, 113, 1019, 10, 113, 12, 113, 14, 113, 1022, 11, 113, 3, 114, 3, 114,
	5, 114, 1026, 10, 114, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 116,
	3, 116, 3, 117, 3, 117, 3, 117, 7, 117, 1038, 10, 117, 12, 117, 14, 117,
	1041, 11, 117, 3, 118, 3, 118, 3, 118, 3, 119, 3, 119, 3, 119, 3, 119,
	3, 119, 3, 120, 3, 120, 3, 120, 3, 120, 5, 120, 1055, 10, 120, 3, 120,
	3, 120, 5, 120, 1059, 10, 120, 5, 120, 1061, 10, 120, 3, 121, 3, 121, 3,
	122, 3, 122, 3, 122, 7, 122, 1068, 10, 122, 12, 122, 14, 122, 1071, 11,
	122, 3, 123, 3, 123, 3, 123, 5, 123, 1076, 10, 123, 3, 124, 3, 124, 3,
	124, 3, 124, 5, 124, 1082, 10, 124, 3, 124, 3, 124, 3, 125, 3, 125, 3,
	126, 3, 126, 5, 126, 1090, 10, 126, 3, 127, 3, 127, 3, 127, 5, 127, 1095,
	10, 127, 3, 128, 3, 128, 3, 128, 3, 128, 7, 128, 1101, 10, 128, 12, 128,
	14, 128, 1104, 11, 128, 3, 128, 3, 128, 3, 129, 3, 129, 5, 129, 1110, 10,
	129, 3, 130, 3, 130, 3, 130, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3,
	131, 5, 131, 1121, 10, 131, 3, 132, 3, 132, 3, 133, 3, 133, 3, 133, 3,
	133, 3, 133, 5, 133, 1130, 10, 133, 3, 134, 3, 134, 3, 134, 7, 134, 1135,
	10, 134, 12, 134, 14, 134, 1138, 11, 134, 3, 135, 3, 135, 3, 135, 3, 136,
	3, 136, 3, 136, 3, 136, 5, 136, 1147, 10, 136, 3, 136, 3, 136, 3, 136,
	3, 136, 3, 136, 7, 136, 1154, 10, 136, 12, 136, 14, 136, 1157, 11, 136,
	3, 136, 3, 136, 5, 136, 1161, 10, 136, 3, 137, 3, 137, 3, 137, 5, 137,
	1166, 10, 137, 3, 137, 3, 137, 3, 138, 3, 138, 5, 138, 1172, 10, 138, 3,
	139, 3, 139, 3, 139, 7, 139, 1177, 10, 139, 12, 139, 14, 139, 1180, 11,
	139, 3, 140, 3, 140, 3, 140, 3, 141, 3, 141, 3, 141, 3, 141, 3, 141, 3,
	141, 3, 141, 5, 141, 1192, 10, 141, 3, 142, 3, 142, 3, 142, 7, 142, 1197,
	10, 142, 12, 142, 14, 142, 1200, 11, 142, 3, 143, 3, 143, 3, 143, 3, 143,
	5, 143, 1206, 10, 143, 3, 143, 3, 143, 3, 144, 3, 144, 3, 144, 2, 2, 145,
	2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
	40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
	76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
	110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
	140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
	170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
	200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
	230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
	260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 2,
	8, 4, 2, 72, 72, 74, 75, 3, 2, 59, 60, 4, 2, 23, 23, 106, 106, 3, 2, 46,
	47, 4, 2, 45, 45, 48, 48, 4, 2, 7, 8, 18, 19, 2, 1242, 2, 288, 3, 2, 2,
	2, 4, 312, 3, 2, 2, 2, 6, 316, 3, 2, 2, 2, 8, 322, 3, 2, 2, 2, 10, 331,
	3, 2, 2, 2, 12, 334, 3, 2, 2, 2, 14, 340, 3, 2, 2, 2, 16, 343, 3, 2, 2,
	2, 18, 345, 3, 2, 2, 2, 20, 352, 3, 2, 2, 2, 22, 356, 3, 2, 2, 2, 24, 359,
	3, 2, 2, 2, 26, 361, 3, 2, 2, 2, 28, 369, 3, 2, 2, 2, 30, 374, 3, 2, 2,
	2, 32, 381, 3, 2, 2, 2, 34, 388, 3, 2, 2, 2, 36, 398, 3, 2, 2, 2, 38, 404,
	3, 2, 2, 2, 40, 426, 3, 2, 2, 2, 42, 428, 3, 2, 2, 2, 44, 430, 3, 2, 2,
	2, 46, 447, 3, 2, 2, 2, 48, 451, 3, 2, 2, 2, 50, 453, 3, 2, 2, 2, 52, 463,
	3, 2, 2, 2, 54, 465, 3, 2, 2, 2, 56, 472, 3, 2, 2, 2, 58, 474, 3, 2, 2,
	2, 60, 489, 3, 2, 2, 2, 62, 506, 3, 2, 2, 2, 64, 508, 3, 2, 2, 2, 66, 522,
	3, 2, 2, 2, 68, 528, 3, 2, 2, 2, 70, 532, 3, 2, 2, 2, 72, 534, 3, 2, 2,
	2, 74, 539, 3, 2, 2, 2, 76, 548, 3, 2, 2, 2, 78, 550, 3, 2, 2, 2, 80, 552,
	3, 2, 2, 2, 82, 556, 3, 2, 2, 2, 84, 570, 3, 2, 2, 2, 86, 574, 3, 2, 2,
	2, 88, 584, 3, 2, 2, 2, 90, 586, 3, 2, 2, 2, 92, 596, 3, 2, 2, 2, 94, 598,
	3, 2, 2, 2, 96, 600, 3, 2, 2, 2, 98, 603, 3, 2, 2, 2, 100, 640, 3, 2, 2,
	2, 102, 648, 3, 2, 2, 2, 104, 650, 3, 2, 2, 2, 106, 662, 3, 2, 2, 2, 108,
	664, 3, 2, 2, 2, 110, 670, 3, 2, 2, 2, 112, 679, 3, 2, 2, 2, 114, 683,
	3, 2, 2, 2, 116, 685, 3, 2, 2, 2, 118, 688, 3, 2, 2, 2, 120, 692, 3, 2,
	2, 2, 122, 710, 3, 2, 2, 2, 124, 712, 3, 2, 2, 2, 126, 723, 3, 2, 2, 2,
	128, 727, 3, 2, 2, 2, 130, 736, 3, 2, 2, 2, 132, 738, 3, 2, 2, 2, 134,
	743, 3, 2, 2, 2, 136, 745, 3, 2, 2, 2, 138, 754, 3, 2, 2, 2, 140, 757,
	3, 2, 2, 2, 142, 766, 3, 2, 2, 2, 144, 768, 3, 2, 2, 2, 146, 770, 3, 2,
	2, 2, 148, 774, 3, 2, 2, 2, 150, 776, 3, 2, 2, 2, 152, 799, 3, 2, 2, 2,
	154, 801, 3, 2, 2, 2, 156, 807, 3, 2, 2, 2, 158, 816, 3, 2, 2, 2, 160,
	818, 3, 2, 2, 2, 162, 827, 3, 2, 2, 2, 164, 829, 3, 2, 2, 2, 166, 832,
	3, 2, 2, 2, 168, 838, 3, 2, 2, 2, 170, 857, 3, 2, 2, 2, 172, 859, 3, 2,
	2, 2, 174, 863, 3, 2, 2, 2, 176, 873, 3, 2, 2, 2, 178, 883, 3, 2, 2, 2,
	180, 885, 3, 2, 2, 2, 182, 893, 3, 2, 2, 2, 184, 902, 3, 2, 2, 2, 186,
	904, 3, 2, 2, 2, 188, 920, 3, 2, 2, 2, 190, 922, 3, 2, 2, 2, 192, 930,
	3, 2, 2, 2, 194, 932, 3, 2, 2, 2, 196, 945, 3, 2, 2, 2, 198, 947, 3, 2,
	2, 2, 200, 949, 3, 2, 2, 2, 202, 957, 3, 2, 2, 2, 204, 959, 3, 2, 2, 2,
	206, 963, 3, 2, 2, 2, 208, 981, 3, 2, 2, 2, 210, 985, 3, 2, 2, 2, 212,
	987, 3, 2, 2, 2, 214, 991, 3, 2, 2, 2, 216, 994, 3, 2, 2, 2, 218, 998,
	3, 2, 2, 2, 220, 1003, 3, 2, 2, 2, 222, 1013, 3, 2, 2, 2, 224, 1015, 3,
	2, 2, 2, 226, 1025, 3, 2, 2, 2, 228, 1027, 3, 2, 2, 2, 230, 1032, 3, 2,
	2, 2, 232, 1034, 3, 2, 2, 2, 234, 1042, 3, 2, 2, 2, 236, 1045, 3, 2, 2,
	2, 238, 1050, 3, 2, 2, 2, 240, 1062, 3, 2, 2, 2, 242, 1064, 3, 2, 2, 2,
	244, 1075, 3, 2, 2, 2, 246, 1077, 3, 2, 2, 2, 248, 1085, 3, 2, 2, 2, 250,
	1087, 3, 2, 2, 2, 252, 1091, 3, 2, 2, 2, 254, 1096, 3, 2, 2, 2, 256, 1109,
	3, 2, 2, 2, 258, 1111, 3, 2, 2, 2, 260, 1120, 3, 2, 2, 2, 262, 1122, 3,
	2, 2, 2, 264, 1124, 3, 2, 2, 2, 266, 1131, 3, 2, 2, 2, 268, 1139, 3, 2,
	2, 2, 270, 1142, 3, 2, 2, 2, 272, 1165, 3, 2, 2, 2, 274, 1171, 3, 2, 2,
	2, 276, 1173, 3, 2, 2, 2, 278, 1181, 3, 2, 2, 2, 280, 1184, 3, 2, 2, 2,
	282, 1193, 3, 2, 2, 2, 284, 1201, 3, 2, 2, 2, 286, 1209, 3, 2, 2, 2, 288,
	300, 7, 106, 2, 2, 289, 296, 7, 21, 2, 2, 290, 291, 7, 106, 2, 2, 291,
	292, 7, 24, 2, 2, 292, 293, 7, 100, 2, 2, 293, 295, 7, 25, 2, 2, 294, 290,
	3, 2, 2, 2, 295, 298, 3, 2, 2, 2, 296, 294, 3, 2, 2, 2, 296, 297, 3, 2,
	2, 2, 297, 299, 3, 2, 2, 2, 298, 296, 3, 2, 2, 2, 299, 301, 7, 22, 2, 2,
	300, 289, 3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 302, 3, 2, 2, 2, 302,
	303, 7, 76, 2, 2, 303, 304, 5, 4, 3, 2, 304, 305, 5, 6, 4, 2, 305, 306,
	7, 5, 2, 2, 306, 307, 7, 77, 2, 2, 307, 308, 5, 8, 5, 2, 308, 309, 7, 78,
	2, 2, 309, 3, 3, 2, 2, 2, 310, 311, 9, 2, 2, 2, 311, 313, 7, 73, 2, 2,
	312, 310, 3, 2, 2, 2, 312, 313, 3, 2, 2, 2, 313, 5, 3, 2, 2, 2, 314, 315,
	7, 70, 2, 2, 315, 317, 7, 71, 2, 2, 316, 314, 3, 2, 2, 2, 316, 317, 3,
	2, 2, 2, 317, 7, 3, 2, 2, 2, 318, 319, 5, 10, 6, 2, 319, 320, 5, 14, 8,
	2, 320, 321, 5, 30, 16, 2, 321, 323, 3, 2, 2, 2, 322, 318, 3, 2, 2, 2,
	322, 323, 3, 2, 2, 2, 323, 9, 3, 2, 2, 2, 324, 325, 7, 69, 2, 2, 325, 326,
	5, 12, 7, 2, 326, 327, 7, 67, 2, 2, 327, 332, 3, 2, 2, 2, 328, 329, 7,
	69, 2, 2, 329, 330, 7, 43, 2, 2, 330, 332, 7, 67, 2, 2, 331, 324, 3, 2,
	2, 2, 331, 328, 3, 2, 2, 2, 331, 332, 3, 2, 2, 2, 332, 11, 3, 2, 2, 2,
	333, 335, 5, 26, 14, 2, 334, 333, 3, 2, 2, 2, 334, 335, 3, 2, 2, 2, 335,
	13, 3, 2, 2, 2, 336, 337, 7, 68, 2, 2, 337, 338, 5, 16, 9, 2, 338, 339,
	7, 67, 2, 2, 339, 341, 3, 2, 2, 2, 340, 336, 3, 2, 2, 2, 340, 341, 3, 2,
	2, 2, 341, 15, 3, 2, 2, 2, 342, 344, 5, 18, 10, 2, 343, 342, 3, 2, 2, 2,
	343, 344, 3, 2, 2, 2, 344, 17, 3, 2, 2, 2, 345, 349, 5, 20, 11, 2, 346,
	348, 5, 20, 11, 2, 347, 346, 3, 2, 2, 2, 348, 351, 3, 2, 2, 2, 349, 347,
	3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 19, 3, 2, 2, 2, 351, 349, 3, 2,
	2, 2, 352, 353, 5, 26, 14, 2, 353, 354, 7, 53, 2, 2, 354, 355, 5, 22, 12,
	2, 355, 21, 3, 2, 2, 2, 356, 357, 7, 106, 2, 2, 357, 358, 5, 24, 13, 2,
	358, 23, 3, 2, 2, 2, 359, 360, 3, 2, 2, 2, 360, 25, 3, 2, 2, 2, 361, 366,
	5, 28, 15, 2, 362, 363, 7, 23, 2, 2, 363, 365, 5, 28, 15, 2, 364, 362,
	3, 2, 2, 2, 365, 368, 3, 2, 2, 2, 366, 364, 3, 2, 2, 2, 366, 367, 3, 2,
	2, 2, 367, 27, 3, 2, 2, 2, 368, 366, 3, 2, 2, 2, 369, 372, 7, 106, 2, 2,
	370, 371, 7, 21, 2, 2, 371, 373, 7, 22, 2, 2, 372, 370, 3, 2, 2, 2, 372,
	373, 3, 2, 2, 2, 373, 29, 3, 2, 2, 2, 374, 378, 5, 32, 17, 2, 375, 377,
	5, 32, 17, 2, 376, 375, 3, 2, 2, 2, 377, 380, 3, 2, 2, 2, 378, 376, 3,
	2, 2, 2, 378, 379, 3, 2, 2, 2, 379, 31, 3, 2, 2, 2, 380, 378, 3, 2, 2,
	2, 381, 386, 7, 106, 2, 2, 382, 387, 5, 166, 84, 2, 383, 387, 5, 164, 83,
	2, 384, 387, 5, 62, 32, 2, 385, 387, 5, 72, 37, 2, 386, 382, 3, 2, 2, 2,
	386, 383, 3, 2, 2, 2, 386, 384, 3, 2, 2, 2, 386, 385, 3, 2, 2, 2, 387,
	33, 3, 2, 2, 2, 388, 389, 7, 36, 2, 2, 389, 394, 7, 21, 2, 2, 390, 391,
	5, 36, 19, 2, 391, 392, 5, 38, 20, 2, 392, 395, 3, 2, 2, 2, 393, 395, 5,
	40, 21, 2, 394, 390, 3, 2, 2, 2, 394, 393, 3, 2, 2, 2, 394, 395, 3, 2,
	2, 2, 395, 396, 3, 2, 2, 2, 396, 397, 7, 22, 2, 2, 397, 35, 3, 2, 2, 2,
	398, 400, 7, 11, 2, 2, 399, 401, 5, 258, 130, 2, 400, 399, 3, 2, 2, 2,
	400, 401, 3, 2, 2, 2, 401, 37, 3, 2, 2, 2, 402, 403, 7, 23, 2, 2, 403,
	405, 7, 11, 2, 2, 404, 402, 3, 2, 2, 2, 404, 405, 3, 2, 2, 2, 405, 39,
	3, 2, 2, 2, 406, 416, 5, 42, 22, 2, 407, 408, 7, 23, 2, 2, 408, 409, 5,
	36, 19, 2, 409, 414, 5, 48, 25, 2, 410, 415, 5, 38, 20, 2, 411, 412, 7,
	99, 2, 2, 412, 413, 7, 23, 2, 2, 413, 415, 5, 42, 22, 2, 414, 410, 3, 2,
	2, 2, 414, 411, 3, 2, 2, 2, 415, 417, 3, 2, 2, 2, 416, 407, 3, 2, 2, 2,
	416, 417, 3, 2, 2, 2, 417, 427, 3, 2, 2, 2, 418, 419, 5, 36, 19, 2, 419,
	424, 5, 48, 25, 2, 420, 425, 5, 38, 20, 2, 421, 422, 7, 99, 2, 2, 422,
	423, 7, 23, 2, 2, 423, 425, 5, 42, 22, 2, 424, 420, 3, 2, 2, 2, 424, 421,
	3, 2, 2, 2, 425, 427, 3, 2, 2, 2, 426, 406, 3, 2, 2, 2, 426, 418, 3, 2,
	2, 2, 427, 41, 3, 2, 2, 2, 428, 429, 5, 44, 23, 2, 429, 43, 3, 2, 2, 2,
	430, 435, 5, 46, 24, 2, 431, 432, 7, 23, 2, 2, 432, 434, 5, 46, 24, 2,
	433, 431, 3, 2, 2, 2, 434, 437, 3, 2, 2, 2, 435, 433, 3, 2, 2, 2, 435,
	436, 3, 2, 2, 2, 436, 45, 3, 2, 2, 2, 437, 435, 3, 2, 2, 2, 438, 442, 5,
	234, 118, 2, 439, 443, 7, 37, 2, 2, 440, 441, 7, 38, 2, 2, 441, 443, 5,
	200, 101, 2, 442, 439, 3, 2, 2, 2, 442, 440, 3, 2, 2, 2, 442, 443, 3, 2,
	2, 2, 443, 448, 3, 2, 2, 2, 444, 445, 7, 39, 2, 2, 445, 446, 7, 40, 2,
	2, 446, 448, 5, 168, 85, 2, 447, 438, 3, 2, 2, 2, 447, 444, 3, 2, 2, 2,
	448, 47, 3, 2, 2, 2, 449, 450, 7, 23, 2, 2, 450, 452, 5, 50, 26, 2, 451,
	449, 3, 2, 2, 2, 451, 452, 3, 2, 2, 2, 452, 49, 3, 2, 2, 2, 453, 458, 5,
	52, 27, 2, 454, 455, 7, 23, 2, 2, 455, 457, 5, 52, 27, 2, 456, 454, 3,
	2, 2, 2, 457, 460, 3, 2, 2, 2, 458, 456, 3, 2, 2, 2, 458, 459, 3, 2, 2,
	2, 459, 51, 3, 2, 2, 2, 460, 458, 3, 2, 2, 2, 461, 464, 5, 46, 24, 2, 462,
	464, 5, 54, 28, 2, 463, 461, 3, 2, 2, 2, 463, 462, 3, 2, 2, 2, 464, 53,
	3, 2, 2, 2, 465, 466, 7, 79, 2, 2, 466, 467, 5, 56, 29, 2, 467, 468, 5,
	44, 23, 2, 468, 469, 7, 80, 2, 2, 469, 55, 3, 2, 2, 2, 470, 471, 7, 100,
	2, 2, 471, 473, 7, 81, 2, 2, 472, 470, 3, 2, 2, 2, 472, 473, 3, 2, 2, 2,
	473, 57, 3, 2, 2, 2, 474, 482, 7, 36, 2, 2, 475, 478, 7, 24, 2, 2, 476,
	479, 5, 182, 92, 2, 477, 479, 5, 60, 31, 2, 478, 476, 3, 2, 2, 2, 478,
	477, 3, 2, 2, 2, 479, 480, 3, 2, 2, 2, 480, 481, 7, 25, 2, 2, 481, 483,
	3, 2, 2, 2, 482, 475, 3, 2, 2, 2, 482, 483, 3, 2, 2, 2, 483, 484, 3, 2,
	2, 2, 484, 487, 7, 40, 2, 2, 485, 488, 5, 168, 85, 2, 486, 488, 5, 234,
	118, 2, 487, 485, 3, 2, 2, 2, 487, 486, 3, 2, 2, 2, 488, 59, 3, 2, 2, 2,
	489, 490, 7, 52, 2, 2, 490, 491, 5, 182, 92, 2, 491, 61, 3, 2, 2, 2, 492,
	493, 5, 64, 33, 2, 493, 497, 7, 5, 2, 2, 494, 498, 5, 168, 85, 2, 495,
	498, 5, 200, 101, 2, 496, 498, 5, 126, 64, 2, 497, 494, 3, 2, 2, 2, 497,
	495, 3, 2, 2, 2, 497, 496, 3, 2, 2, 2, 498, 507, 3, 2, 2, 2, 499, 500,
	5, 76, 39, 2, 500, 504, 7, 5, 2, 2, 501, 505, 5, 114, 58, 2, 502, 505,
	5, 74, 38, 2, 503, 505, 5, 120, 61, 2, 504, 501, 3, 2, 2, 2, 504, 502,
	3, 2, 2, 2, 504, 503, 3, 2, 2, 2, 505, 507, 3, 2, 2, 2, 506, 492, 3, 2,
	2, 2, 506, 499, 3, 2, 2, 2, 507, 63, 3, 2, 2, 2, 508, 509, 7, 21, 2, 2,
	509, 514, 5, 66, 34, 2, 510, 511, 7, 23, 2, 2, 511, 513, 5, 66, 34, 2,
	512, 510, 3, 2, 2, 2, 513, 516, 3, 2, 2, 2, 514, 512, 3, 2, 2, 2, 514,
	515, 3, 2, 2, 2, 515, 517, 3, 2, 2, 2, 516, 514, 3, 2, 2, 2, 517, 518,
	7, 22, 2, 2, 518, 65, 3, 2, 2, 2, 519, 520, 5, 68, 35, 2, 520, 521, 7,
	81, 2, 2, 521, 523, 3, 2, 2, 2, 522, 519, 3, 2, 2, 2, 522, 523, 3, 2, 2,
	2, 523, 524, 3, 2, 2, 2, 524, 525, 7, 106, 2, 2, 525, 67, 3, 2, 2, 2, 526,
	529, 5, 70, 36, 2, 527, 529, 7, 106, 2, 2, 528, 526, 3, 2, 2, 2, 528, 527,
	3, 2, 2, 2, 529, 69, 3, 2, 2, 2, 530, 533, 5, 168, 85, 2, 531, 533, 5,
	76, 39, 2, 532, 530, 3, 2, 2, 2, 532, 531, 3, 2, 2, 2, 533, 71, 3, 2, 2,
	2, 534, 535, 7, 5, 2, 2, 535, 536, 5, 74, 38, 2, 536, 73, 3, 2, 2, 2, 537,
	540, 5, 76, 39, 2, 538, 540, 5, 82, 42, 2, 539, 537, 3, 2, 2, 2, 539, 538,
	3, 2, 2, 2, 540, 75, 3, 2, 2, 2, 541, 542, 7, 106, 2, 2, 542, 544, 7, 9,
	2, 2, 543, 541, 3, 2, 2, 2, 543, 544, 3, 2, 2, 2, 544, 545, 3, 2, 2, 2,
	545, 549, 7, 106, 2, 2, 546, 549, 7, 59, 2, 2, 547, 549, 7, 60, 2, 2, 548,
	543, 3, 2, 2, 2, 548, 546, 3, 2, 2, 2, 548, 547, 3, 2, 2, 2, 549, 77, 3,
	2, 2, 2, 550, 551, 9, 3, 2, 2, 551, 79, 3, 2, 2, 2, 552, 553, 7, 106, 2,
	2, 553, 554, 7, 9, 2, 2, 554, 555, 7, 106, 2, 2, 555, 81, 3, 2, 2, 2, 556,
	557, 7, 61, 2, 2, 557, 558, 7, 21, 2, 2, 558, 563, 5, 98, 50, 2, 559, 560,
	7, 23, 2, 2, 560, 562, 5, 98, 50, 2, 561, 559, 3, 2, 2, 2, 562, 565, 3,
	2, 2, 2, 563, 561, 3, 2, 2, 2, 563, 564, 3, 2, 2, 2, 564, 566, 3, 2, 2,
	2, 565, 563, 3, 2, 2, 2, 566, 568, 7, 22, 2, 2, 567, 569, 5, 84, 43, 2,
	568, 567, 3, 2, 2, 2, 568, 569, 3, 2, 2, 2, 569, 83, 3, 2, 2, 2, 570, 571,
	7, 54, 2, 2, 571, 572, 7, 63, 2, 2, 572, 573, 5, 86, 44, 2, 573, 85, 3,
	2, 2, 2, 574, 576, 7, 21, 2, 2, 575, 577, 5, 88, 45, 2, 576, 575, 3, 2,
	2, 2, 577, 578, 3, 2, 2, 2, 578, 576, 3, 2, 2, 2, 578, 579, 3, 2, 2, 2,
	579, 580, 3, 2, 2, 2, 580, 581, 7, 22, 2, 2, 581, 87, 3, 2, 2, 2, 582,
	585, 5, 92, 47, 2, 583, 585, 5, 90, 46, 2, 584, 582, 3, 2, 2, 2, 584, 583,
	3, 2, 2, 2, 585, 89, 3, 2, 2, 2, 586, 588, 7, 64, 2, 2, 587, 589, 5, 88,
	45, 2, 588, 587, 3, 2, 2, 2, 589, 590, 3, 2, 2, 2, 590, 588, 3, 2, 2, 2,
	590, 591, 3, 2, 2, 2, 591, 592, 3, 2, 2, 2, 592, 593, 7, 65, 2, 2, 593,
	91, 3, 2, 2, 2, 594, 597, 5, 94, 48, 2, 595, 597, 5, 96, 49, 2, 596, 594,
	3, 2, 2, 2, 596, 595, 3, 2, 2, 2, 597, 93, 3, 2, 2, 2, 598, 599, 9, 4,
	2, 2, 599, 95, 3, 2, 2, 2, 600, 601, 7, 13, 2, 2, 601, 602, 7, 106, 2,
	2, 602, 97, 3, 2, 2, 2, 603, 604, 7, 13, 2, 2, 604, 638, 7, 106, 2, 2,
	605, 607, 5, 102, 52, 2, 606, 605, 3, 2, 2, 2, 606, 607, 3, 2, 2, 2, 607,
	639, 3, 2, 2, 2, 608, 618, 5, 168, 85, 2, 609, 611, 5, 112, 57, 2, 610,
	609, 3, 2, 2, 2, 610, 611, 3, 2, 2, 2, 611, 619, 3, 2, 2, 2, 612, 614,
	7, 62, 2, 2, 613, 612, 3, 2, 2, 2, 613, 614, 3, 2, 2, 2, 614, 616, 3, 2,
	2, 2, 615, 617, 5, 106, 54, 2, 616, 615, 3, 2, 2, 2, 616, 617, 3, 2, 2,
	2, 617, 619, 3, 2, 2, 2, 618, 610, 3, 2, 2, 2, 618, 613, 3, 2, 2, 2, 619,
	639, 3, 2, 2, 2, 620, 627, 5, 124, 63, 2, 621, 628, 7, 37, 2, 2, 622, 625,
	7, 38, 2, 2, 623, 626, 5, 126, 64, 2, 624, 626, 5, 200, 101, 2, 625, 623,
	3, 2, 2, 2, 625, 624, 3, 2, 2, 2, 626, 628, 3, 2, 2, 2, 627, 621, 3, 2,
	2, 2, 627, 622, 3, 2, 2, 2, 627, 628, 3, 2, 2, 2, 628, 639, 3, 2, 2, 2,
	629, 636, 5, 76, 39, 2, 630, 637, 7, 37, 2, 2, 631, 634, 7, 38, 2, 2, 632,
	635, 5, 120, 61, 2, 633, 635, 5, 114, 58, 2, 634, 632, 3, 2, 2, 2, 634,
	633, 3, 2, 2, 2, 635, 637, 3, 2, 2, 2, 636, 630, 3, 2, 2, 2, 636, 631,
	3, 2, 2, 2, 636, 637, 3, 2, 2, 2, 637, 639, 3, 2, 2, 2, 638, 606, 3, 2,
	2, 2, 638, 608, 3, 2, 2, 2, 638, 620, 3, 2, 2, 2, 638, 629, 3, 2, 2, 2,
	639, 99, 3, 2, 2, 2, 640, 641, 7, 13, 2, 2, 641, 643, 7, 106, 2, 2, 642,
	644, 5, 102, 52, 2, 643, 642, 3, 2, 2, 2, 643, 644, 3, 2, 2, 2, 644, 101,
	3, 2, 2, 2, 645, 649, 7, 37, 2, 2, 646, 647, 7, 38, 2, 2, 647, 649, 5,
	168, 85, 2, 648, 645, 3, 2, 2, 2, 648, 646, 3, 2, 2, 2, 649, 103, 3, 2,
	2, 2, 650, 651, 7, 13, 2, 2, 651, 652, 7, 106, 2, 2, 652, 654, 5, 168,
	85, 2, 653, 655, 7, 62, 2, 2, 654, 653, 3, 2, 2, 2, 654, 655, 3, 2, 2,
	2, 655, 657, 3, 2, 2, 2, 656, 658, 5, 106, 54, 2, 657, 656, 3, 2, 2, 2,
	657, 658, 3, 2, 2, 2, 658, 105, 3, 2, 2, 2, 659, 663, 7, 37, 2, 2, 660,
	661, 7, 38, 2, 2, 661, 663, 5, 200, 101, 2, 662, 659, 3, 2, 2, 2, 662,
	660, 3, 2, 2, 2, 663, 107, 3, 2, 2, 2, 664, 665, 7, 13, 2, 2, 665, 666,
	7, 106, 2, 2, 666, 668, 5, 124, 63, 2, 667, 669, 5, 106, 54, 2, 668, 667,
	3, 2, 2, 2, 668, 669, 3, 2, 2, 2, 669, 109, 3, 2, 2, 2, 670, 671, 7, 13,
	2, 2, 671, 672, 7, 106, 2, 2, 672, 674, 5, 168, 85, 2, 673, 675, 5, 112,
	57, 2, 674, 673, 3, 2, 2, 2, 674, 675, 3, 2, 2, 2, 675, 111, 3, 2, 2, 2,
	676, 680, 7, 37, 2, 2, 677, 678, 7, 38, 2, 2, 678, 680, 5, 126, 64, 2,
	679, 676, 3, 2, 2, 2, 679, 677, 3, 2, 2, 2, 680, 113, 3, 2, 2, 2, 681,
	684, 5, 118, 60, 2, 682, 684, 5, 116, 59, 2, 683, 681, 3, 2, 2, 2, 683,
	682, 3, 2, 2, 2, 684, 115, 3, 2, 2, 2, 685, 686, 5, 118, 60, 2, 686, 687,
	5, 254, 128, 2, 687, 117, 3, 2, 2, 2, 688, 690, 7, 106, 2, 2, 689, 691,
	7, 9, 2, 2, 690, 689, 3, 2, 2, 2, 690, 691, 3, 2, 2, 2, 691, 119, 3, 2,
	2, 2, 692, 693, 7, 21, 2, 2, 693, 694, 5, 122, 62, 2, 694, 695, 7, 22,
	2, 2, 695, 121, 3, 2, 2, 2, 696, 703, 5, 130, 66, 2, 697, 698, 7, 23, 2,
	2, 698, 701, 7, 11, 2, 2, 699, 700, 7, 23, 2, 2, 700, 702, 5, 132, 67,
	2, 701, 699, 3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702, 704, 3, 2, 2, 2, 703,
	697, 3, 2, 2, 2, 703, 704, 3, 2, 2, 2, 704, 711, 3, 2, 2, 2, 705, 708,
	7, 11, 2, 2, 706, 707, 7, 23, 2, 2, 707, 709, 5, 132, 67, 2, 708, 706,
	3, 2, 2, 2, 708, 709, 3, 2, 2, 2, 709, 711, 3, 2, 2, 2, 710, 696, 3, 2,
	2, 2, 710, 705, 3, 2, 2, 2, 711, 123, 3, 2, 2, 2, 712, 713, 7, 13, 2, 2,
	713, 714, 7, 106, 2, 2, 714, 720, 3, 2, 2, 2, 715, 716, 7, 13, 2, 2, 716,
	717, 7, 106, 2, 2, 717, 719, 7, 9, 2, 2, 718, 715, 3, 2, 2, 2, 719, 722,
	3, 2, 2, 2, 720, 718, 3, 2, 2, 2, 720, 721, 3, 2, 2, 2, 721, 125, 3, 2,
	2, 2, 722, 720, 3, 2, 2, 2, 723, 724, 7, 21, 2, 2, 724, 725, 5, 128, 65,
	2, 725, 726, 7, 22, 2, 2, 726, 127, 3, 2, 2, 2, 727, 734, 5, 130, 66, 2,
	728, 729, 7, 23, 2, 2, 729, 732, 7, 11, 2, 2, 730, 731, 7, 23, 2, 2, 731,
	733, 5, 132, 67, 2, 732, 730, 3, 2, 2, 2, 732, 733, 3, 2, 2, 2, 733, 735,
	3, 2, 2, 2, 734, 728, 3, 2, 2, 2, 734, 735, 3, 2, 2, 2, 735, 129, 3, 2,
	2, 2, 736, 737, 5, 134, 68, 2, 737, 131, 3, 2, 2, 2, 738, 739, 5, 134,
	68, 2, 739, 133, 3, 2, 2, 2, 740, 744, 5, 136, 69, 2, 741, 742, 7, 43,
	2, 2, 742, 744, 5, 138, 70, 2, 743, 740, 3, 2, 2, 2, 743, 741, 3, 2, 2,
	2, 744, 135, 3, 2, 2, 2, 745, 751, 5, 140, 71, 2, 746, 747, 5, 142, 72,
	2, 747, 748, 5, 140, 71, 2, 748, 750, 3, 2, 2, 2, 749, 746, 3, 2, 2, 2,
	750, 753, 3, 2, 2, 2, 751, 749, 3, 2, 2, 2, 751, 752, 3, 2, 2, 2, 752,
	137, 3, 2, 2, 2, 753, 751, 3, 2, 2, 2, 754, 755, 7, 44, 2, 2, 755, 756,
	5, 146, 74, 2, 756, 139, 3, 2, 2, 2, 757, 763, 5, 150, 76, 2, 758, 759,
	5, 144, 73, 2, 759, 760, 5, 150, 76, 2, 760, 762, 3, 2, 2, 2, 761, 758,
	3, 2, 2, 2, 762, 765, 3, 2, 2, 2, 763, 761, 3, 2, 2, 2, 763, 764, 3, 2,
	2, 2, 764, 141, 3, 2, 2, 2, 765, 763, 3, 2, 2, 2, 766, 767, 9, 5, 2, 2,
	767, 143, 3, 2, 2, 2, 768, 769, 9, 6, 2, 2, 769, 145, 3, 2, 2, 2, 770,
	771, 5, 152, 77, 2, 771, 147, 3, 2, 2, 2, 772, 775, 5, 114, 58, 2, 773,
	775, 5, 118, 60, 2, 774, 772, 3, 2, 2, 2, 774, 773, 3, 2, 2, 2, 775, 149,
	3, 2, 2, 2, 776, 778, 5, 146, 74, 2, 777, 779, 5, 138, 70, 2, 778, 777,
	3, 2, 2, 2, 778, 779, 3, 2, 2, 2, 779, 151, 3, 2, 2, 2, 780, 783, 5, 200,
	101, 2, 781, 783, 7, 50, 2, 2, 782, 780, 3, 2, 2, 2, 782, 781, 3, 2, 2,
	2, 783, 785, 3, 2, 2, 2, 784, 786, 7, 14, 2, 2, 785, 784, 3, 2, 2, 2, 785,
	786, 3, 2, 2, 2, 786, 787, 3, 2, 2, 2, 787, 789, 7, 10, 2, 2, 788, 790,
	7, 14, 2, 2, 789, 788, 3, 2, 2, 2, 789, 790, 3, 2, 2, 2, 790, 793, 3, 2,
	2, 2, 791, 794, 5, 200, 101, 2, 792, 794, 7, 51, 2, 2, 793, 791, 3, 2,
	2, 2, 793, 792, 3, 2, 2, 2, 794, 800, 3, 2, 2, 2, 795, 800, 5, 60, 31,
	2, 796, 797, 7, 58, 2, 2, 797, 800, 5, 200, 101, 2, 798, 800, 5, 200, 101,
	2, 799, 782, 3, 2, 2, 2, 799, 795, 3, 2, 2, 2, 799, 796, 3, 2, 2, 2, 799,
	798, 3, 2, 2, 2, 800, 153, 3, 2, 2, 2, 801, 802, 7, 13, 2, 2, 802, 803,
	7, 106, 2, 2, 803, 805, 5, 124, 63, 2, 804, 806, 5, 112, 57, 2, 805, 804,
	3, 2, 2, 2, 805, 806, 3, 2, 2, 2, 806, 155, 3, 2, 2, 2, 807, 808, 7, 13,
	2, 2, 808, 809, 7, 106, 2, 2, 809, 811, 5, 76, 39, 2, 810, 812, 5, 158,
	80, 2, 811, 810, 3, 2, 2, 2, 811, 812, 3, 2, 2, 2, 812, 157, 3, 2, 2, 2,
	813, 817, 7, 37, 2, 2, 814, 815, 7, 38, 2, 2, 815, 817, 5, 114, 58, 2,
	816, 813, 3, 2, 2, 2, 816, 814, 3, 2, 2, 2, 817, 159, 3, 2, 2, 2, 818,
	819, 7, 13, 2, 2, 819, 820, 7, 106, 2, 2, 820, 822, 5, 76, 39, 2, 821,
	823, 5, 162, 82, 2, 822, 821, 3, 2, 2, 2, 822, 823, 3, 2, 2, 2, 823, 161,
	3, 2, 2, 2, 824, 828, 7, 37, 2, 2, 825, 826, 7, 38, 2, 2, 826, 828, 5,
	120, 61, 2, 827, 824, 3, 2, 2, 2, 827, 825, 3, 2, 2, 2, 828, 163, 3, 2,
	2, 2, 829, 830, 7, 5, 2, 2, 830, 831, 5, 168, 85, 2, 831, 165, 3, 2, 2,
	2, 832, 833, 5, 168, 85, 2, 833, 834, 7, 5, 2, 2, 834, 835, 5, 200, 101,
	2, 835, 167, 3, 2, 2, 2, 836, 839, 5, 170, 86, 2, 837, 839, 5, 178, 90,
	2, 838, 836, 3, 2, 2, 2, 838, 837, 3, 2, 2, 2, 839, 843, 3, 2, 2, 2, 840,
	842, 5, 182, 92, 2, 841, 840, 3, 2, 2, 2, 842, 845, 3, 2, 2, 2, 843, 841,
	3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844, 169, 3, 2, 2, 2, 845, 843, 3, 2,
	2, 2, 846, 858, 5, 278, 140, 2, 847, 858, 5, 280, 141, 2, 848, 858, 5,
	218, 110, 2, 849, 858, 5, 236, 119, 2, 850, 858, 5, 264, 133, 2, 851, 858,
	5, 34, 18, 2, 852, 858, 5, 58, 30, 2, 853, 858, 5, 174, 88, 2, 854, 858,
	5, 176, 89, 2, 855, 858, 5, 268, 135, 2, 856, 858, 5, 172, 87, 2, 857,
	846, 3, 2, 2, 2, 857, 847, 3, 2, 2, 2, 857, 848, 3, 2, 2, 2, 857, 849,
	3, 2, 2, 2, 857, 850, 3, 2, 2, 2, 857, 851, 3, 2, 2, 2, 857, 852, 3, 2,
	2, 2, 857, 853, 3, 2, 2, 2, 857, 854, 3, 2, 2, 2, 857, 855, 3, 2, 2, 2,
	857, 856, 3, 2, 2, 2, 858, 171, 3, 2, 2, 2, 859, 860, 5, 76, 39, 2, 860,
	861, 7, 9, 2, 2, 861, 862, 5, 124, 63, 2, 862, 173, 3, 2, 2, 2, 863, 864,
	7, 41, 2, 2, 864, 869, 7, 21, 2, 2, 865, 866, 5, 36, 19, 2, 866, 867, 5,
	38, 20, 2, 867, 870, 3, 2, 2, 2, 868, 870, 5, 40, 21, 2, 869, 865, 3, 2,
	2, 2, 869, 868, 3, 2, 2, 2, 869, 870, 3, 2, 2, 2, 870, 871, 3, 2, 2, 2,
	871, 872, 7, 22, 2, 2, 872, 175, 3, 2, 2, 2, 873, 876, 7, 41, 2, 2, 874,
	877, 5, 182, 92, 2, 875, 877, 5, 60, 31, 2, 876, 874, 3, 2, 2, 2, 876,
	875, 3, 2, 2, 2, 876, 877, 3, 2, 2, 2, 877, 878, 3, 2, 2, 2, 878, 881,
	7, 40, 2, 2, 879, 882, 5, 168, 85, 2, 880, 882, 5, 234, 118, 2, 881, 879,
	3, 2, 2, 2, 881, 880, 3, 2, 2, 2, 882, 177, 3, 2, 2, 2, 883, 884, 5, 180,
	91, 2, 884, 179, 3, 2, 2, 2, 885, 888, 7, 106, 2, 2, 886, 887, 7, 9, 2,
	2, 887, 889, 7, 106, 2, 2, 888, 886, 3, 2, 2, 2, 888, 889, 3, 2, 2, 2,
	889, 891, 3, 2, 2, 2, 890, 892, 5, 254, 128, 2, 891, 890, 3, 2, 2, 2, 891,
	892, 3, 2, 2, 2, 892, 181, 3, 2, 2, 2, 893, 894, 7, 24, 2, 2, 894, 896,
	5, 184, 93, 2, 895, 897, 5, 258, 130, 2, 896, 895, 3, 2, 2, 2, 896, 897,
	3, 2, 2, 2, 897, 898, 3, 2, 2, 2, 898, 899, 7, 25, 2, 2, 899, 183, 3, 2,
	2, 2, 900, 903, 5, 188, 95, 2, 901, 903, 5, 198, 100, 2, 902, 900, 3, 2,
	2, 2, 902, 901, 3, 2, 2, 2, 903, 185, 3, 2, 2, 2, 904, 905, 7, 93, 2, 2,
	905, 906, 7, 94, 2, 2, 906, 907, 7, 21, 2, 2, 907, 912, 5, 190, 96, 2,
	908, 909, 7, 23, 2, 2, 909, 911, 5, 190, 96, 2, 910, 908, 3, 2, 2, 2, 911,
	914, 3, 2, 2, 2, 912, 910, 3, 2, 2, 2, 912, 913, 3, 2, 2, 2, 913, 915,
	3, 2, 2, 2, 914, 912, 3, 2, 2, 2, 915, 916, 7, 22, 2, 2, 916, 187, 3, 2,
	2, 2, 917, 921, 5, 186, 94, 2, 918, 921, 5, 192, 97, 2, 919, 921, 5, 196,
	99, 2, 920, 917, 3, 2, 2, 2, 920, 918, 3, 2, 2, 2, 920, 919, 3, 2, 2, 2,
	921, 189, 3, 2, 2, 2, 922, 928, 5, 70, 36, 2, 923, 924, 7, 81, 2, 2, 924,
	929, 5, 200, 101, 2, 925, 929, 5, 126, 64, 2, 926, 929, 5, 114, 58, 2,
	927, 929, 5, 120, 61, 2, 928, 923, 3, 2, 2, 2, 928, 925, 3, 2, 2, 2, 928,
	926, 3, 2, 2, 2, 928, 927, 3, 2, 2, 2, 928, 929, 3, 2, 2, 2, 929, 191,
	3, 2, 2, 2, 930, 931, 5, 270, 136, 2, 931, 193, 3, 2, 2, 2, 932, 933, 5,
	120, 61, 2, 933, 195, 3, 2, 2, 2, 934, 935, 7, 33, 2, 2, 935, 946, 5, 168,
	85, 2, 936, 937, 7, 96, 2, 2, 937, 938, 7, 94, 2, 2, 938, 946, 5, 200,
	101, 2, 939, 940, 7, 33, 2, 2, 940, 941, 5, 168, 85, 2, 941, 942, 7, 96,
	2, 2, 942, 943, 7, 94, 2, 2, 943, 944, 5, 200, 101, 2, 944, 946, 3, 2,
	2, 2, 945, 934, 3, 2, 2, 2, 945, 936, 3, 2, 2, 2, 945, 939, 3, 2, 2, 2,
	946, 197, 3, 2, 2, 2, 947, 948, 5, 128, 65, 2, 948, 199, 3, 2, 2, 2, 949,
	950, 5, 202, 102, 2, 950, 201, 3, 2, 2, 2, 951, 958, 5, 214, 108, 2, 952,
	958, 5, 210, 106, 2, 953, 958, 5, 212, 107, 2, 954, 958, 5, 204, 103, 2,
	955, 958, 5, 286, 144, 2, 956, 958, 7, 105, 2, 2, 957, 951, 3, 2, 2, 2,
	957, 952, 3, 2, 2, 2, 957, 953, 3, 2, 2, 2, 957, 954, 3, 2, 2, 2, 957,
	955, 3, 2, 2, 2, 957, 956, 3, 2, 2, 2, 958, 203, 3, 2, 2, 2, 959, 960,
	7, 21, 2, 2, 960, 961, 5, 206, 104, 2, 961, 962, 7, 22, 2, 2, 962, 205,
	3, 2, 2, 2, 963, 967, 5, 208, 105, 2, 964, 966, 5, 208, 105, 2, 965, 964,
	3, 2, 2, 2, 966, 969, 3, 2, 2, 2, 967, 965, 3, 2, 2, 2, 967, 968, 3, 2,
	2, 2, 968, 207, 3, 2, 2, 2, 969, 967, 3, 2, 2, 2, 970, 982, 7, 100, 2,
	2, 971, 978, 7, 106, 2, 2, 972, 975, 7, 24, 2, 2, 973, 976, 7, 100, 2,
	2, 974, 976, 5, 248, 125, 2, 975, 973, 3, 2, 2, 2, 975, 974, 3, 2, 2, 2,
	976, 977, 3, 2, 2, 2, 977, 979, 7, 25, 2, 2, 978, 972, 3, 2, 2, 2, 978,
	979, 3, 2, 2, 2, 979, 982, 3, 2, 2, 2, 980, 982, 5, 248, 125, 2, 981, 970,
	3, 2, 2, 2, 981, 971, 3, 2, 2, 2, 981, 980, 3, 2, 2, 2, 982, 209, 3, 2,
	2, 2, 983, 986, 5, 216, 109, 2, 984, 986, 7, 106, 2, 2, 985, 983, 3, 2,
	2, 2, 985, 984, 3, 2, 2, 2, 986, 211, 3, 2, 2, 2, 987, 988, 7, 106, 2,
	2, 988, 989, 7, 81, 2, 2, 989, 990, 5, 200, 101, 2, 990, 213, 3, 2, 2,
	2, 991, 992, 7, 106, 2, 2, 992, 215, 3, 2, 2, 2, 993, 995, 7, 26, 2, 2,
	994, 993, 3, 2, 2, 2, 994, 995, 3, 2, 2, 2, 995, 996, 3, 2, 2, 2, 996,
	997, 7, 100, 2, 2, 997, 217, 3, 2, 2, 2, 998, 999, 7, 82, 2, 2, 999, 1000,
	7, 21, 2, 2, 1000, 1001, 5, 220, 111, 2, 1001, 1002, 7, 22, 2, 2, 1002,
	219, 3, 2, 2, 2, 1003, 1009, 5, 230, 116, 2, 1004, 1005, 7, 23, 2, 2, 1005,
	1006, 5, 36, 19, 2, 1006, 1007, 5, 222, 112, 2, 1007, 1008, 5, 38, 20,
	2, 1008, 1010, 3, 2, 2, 2, 1009, 1004, 3, 2, 2, 2, 1009, 1010, 3, 2, 2,
	2, 1010, 221, 3, 2, 2, 2, 1011, 1012, 7, 23, 2, 2, 1012, 1014, 5, 224,
	113, 2, 1013, 1011, 3, 2, 2, 2, 1013, 1014, 3, 2, 2, 2, 1014, 223, 3, 2,
	2, 2, 1015, 1020, 5, 226, 114, 2, 1016, 1017, 7, 23, 2, 2, 1017, 1019,
	5, 226, 114, 2, 1018, 1016, 3, 2, 2, 2, 1019, 1022, 3, 2, 2, 2, 1020, 1018,
	3, 2, 2, 2, 1020, 1021, 3, 2, 2, 2, 1021, 225, 3, 2, 2, 2, 1022, 1020,
	3, 2, 2, 2, 1023, 1026, 5, 228, 115, 2, 1024, 1026, 5, 234, 118, 2, 1025,
	1023, 3, 2, 2, 2, 1025, 1024, 3, 2, 2, 2, 1026, 227, 3, 2, 2, 2, 1027,
	1028, 7, 79, 2, 2, 1028, 1029, 5, 56, 29, 2, 1029, 1030, 5, 232, 117, 2,
	1030, 1031, 7, 80, 2, 2, 1031, 229, 3, 2, 2, 2, 1032, 1033, 5, 232, 117,
	2, 1033, 231, 3, 2, 2, 2, 1034, 1039, 5, 234, 118, 2, 1035, 1036, 7, 23,
	2, 2, 1036, 1038, 5, 234, 118, 2, 1037, 1035, 3, 2, 2, 2, 1038, 1041, 3,
	2, 2, 2, 1039, 1037, 3, 2, 2, 2, 1039, 1040, 3, 2, 2, 2, 1040, 233, 3,
	2, 2, 2, 1041, 1039, 3, 2, 2, 2, 1042, 1043, 7, 106, 2, 2, 1043, 1044,
	5, 168, 85, 2, 1044, 235, 3, 2, 2, 2, 1045, 1046, 7, 27, 2, 2, 1046, 1047,
	7, 21, 2, 2, 1047, 1048, 5, 238, 120, 2, 1048, 1049, 7, 22, 2, 2, 1049,
	237, 3, 2, 2, 2, 1050, 1060, 5, 240, 121, 2, 1051, 1052, 7, 23, 2, 2, 1052,
	1054, 7, 11, 2, 2, 1053, 1055, 5, 258, 130, 2, 1054, 1053, 3, 2, 2, 2,
	1054, 1055, 3, 2, 2, 2, 1055, 1058, 3, 2, 2, 2, 1056, 1057, 7, 23, 2, 2,
	1057, 1059, 5, 262, 132, 2, 1058, 1056, 3, 2, 2, 2, 1058, 1059, 3, 2, 2,
	2, 1059, 1061, 3, 2, 2, 2, 1060, 1051, 3, 2, 2, 2, 1060, 1061, 3, 2, 2,
	2, 1061, 239, 3, 2, 2, 2, 1062, 1063, 5, 242, 122, 2, 1063, 241, 3, 2,
	2, 2, 1064, 1069, 5, 244, 123, 2, 1065, 1066, 7, 23, 2, 2, 1066, 1068,
	5, 244, 123, 2, 1067, 1065, 3, 2, 2, 2, 1068, 1071, 3, 2, 2, 2, 1069, 1067,
	3, 2, 2, 2, 1069, 1070, 3, 2, 2, 2, 1070, 243, 3, 2, 2, 2, 1071, 1069,
	3, 2, 2, 2, 1072, 1076, 7, 106, 2, 2, 1073, 1076, 5, 246, 124, 2, 1074,
	1076, 5, 200, 101, 2, 1075, 1072, 3, 2, 2, 2, 1075, 1073, 3, 2, 2, 2, 1075,
	1074, 3, 2, 2, 2, 1076, 245, 3, 2, 2, 2, 1077, 1078, 7, 106, 2, 2, 1078,
	1081, 7, 24, 2, 2, 1079, 1082, 5, 216, 109, 2, 1080, 1082, 5, 248, 125,
	2, 1081, 1079, 3, 2, 2, 2, 1081, 1080, 3, 2, 2, 2, 1082, 1083, 3, 2, 2,
	2, 1083, 1084, 7, 25, 2, 2, 1084, 247, 3, 2, 2, 2, 1085, 1086, 5, 250,
	126, 2, 1086, 249, 3, 2, 2, 2, 1087, 1089, 5, 252, 127, 2, 1088, 1090,
	5, 254, 128, 2, 1089, 1088, 3, 2, 2, 2, 1089, 1090, 3, 2, 2, 2, 1090, 251,
	3, 2, 2, 2, 1091, 1094, 7, 106, 2, 2, 1092, 1093, 7, 9, 2, 2, 1093, 1095,
	7, 106, 2, 2, 1094, 1092, 3, 2, 2, 2, 1094, 1095, 3, 2, 2, 2, 1095, 253,
	3, 2, 2, 2, 1096, 1097, 7, 21, 2, 2, 1097, 1102, 5, 256, 129, 2, 1098,
	1099, 7, 23, 2, 2, 1099, 1101, 5, 256, 129, 2, 1100, 1098, 3, 2, 2, 2,
	1101, 1104, 3, 2, 2, 2, 1102, 1100, 3, 2, 2, 2, 1102, 1103, 3, 2, 2, 2,
	1103, 1105, 3, 2, 2, 2, 1104, 1102, 3, 2, 2, 2, 1105, 1106, 7, 22, 2, 2,
	1106, 255, 3, 2, 2, 2, 1107, 1110, 5, 168, 85, 2, 1108, 1110, 5, 200, 101,
	2, 1109, 1107, 3, 2, 2, 2, 1109, 1108, 3, 2, 2, 2, 1110, 257, 3, 2, 2,
	2, 1111, 1112, 7, 42, 2, 2, 1112, 1113, 5, 260, 131, 2, 1113, 259, 3, 2,
	2, 2, 1114, 1121, 5, 216, 109, 2, 1115, 1121, 5, 248, 125, 2, 1116, 1117,
	5, 168, 85, 2, 1117, 1118, 7, 81, 2, 2, 1118, 1119, 5, 200, 101, 2, 1119,
	1121, 3, 2, 2, 2, 1120, 1114, 3, 2, 2, 2, 1120, 1115, 3, 2, 2, 2, 1120,
	1116, 3, 2, 2, 2, 1121, 261, 3, 2, 2, 2, 1122, 1123, 5, 242, 122, 2, 1123,
	263, 3, 2, 2, 2, 1124, 1129, 7, 20, 2, 2, 1125, 1126, 7, 21, 2, 2, 1126,
	1127, 5, 266, 134, 2, 1127, 1128, 7, 22, 2, 2, 1128, 1130, 3, 2, 2, 2,
	1129, 1125, 3, 2, 2, 2, 1129, 1130, 3, 2, 2, 2, 1130, 265, 3, 2, 2, 2,
	1131, 1136, 5, 246, 124, 2, 1132, 1133, 7, 23, 2, 2, 1133, 1135, 5, 246,
	124, 2, 1134, 1132, 3, 2, 2, 2, 1135, 1138, 3, 2, 2, 2, 1136, 1134, 3,
	2, 2, 2, 1136, 1137, 3, 2, 2, 2, 1137, 267, 3, 2, 2, 2, 1138, 1136, 3,
	2, 2, 2, 1139, 1140, 7, 89, 2, 2, 1140, 1141, 7, 90, 2, 2, 1141, 269, 3,
	2, 2, 2, 1142, 1143, 7, 21, 2, 2, 1143, 1146, 7, 106, 2, 2, 1144, 1145,
	7, 9, 2, 2, 1145, 1147, 7, 106, 2, 2, 1146, 1144, 3, 2, 2, 2, 1146, 1147,
	3, 2, 2, 2, 1147, 1148, 3, 2, 2, 2, 1148, 1160, 7, 22, 2, 2, 1149, 1150,
	7, 21, 2, 2, 1150, 1155, 5, 272, 137, 2, 1151, 1152, 7, 23, 2, 2, 1152,
	1154, 5, 272, 137, 2, 1153, 1151, 3, 2, 2, 2, 1154, 1157, 3, 2, 2, 2, 1155,
	1153, 3, 2, 2, 2, 1155, 1156, 3, 2, 2, 2, 1156, 1158, 3, 2, 2, 2, 1157,
	1155, 3, 2, 2, 2, 1158, 1159, 7, 22, 2, 2, 1159, 1161, 3, 2, 2, 2, 1160,
	1149, 3, 2, 2, 2, 1160, 1161, 3, 2, 2, 2, 1161, 271, 3, 2, 2, 2, 1162,
	1166, 7, 3, 2, 2, 1163, 1164, 7, 95, 2, 2, 1164, 1166, 5, 274, 138, 2,
	1165, 1162, 3, 2, 2, 2, 1165, 1163, 3, 2, 2, 2, 1166, 1167, 3, 2, 2, 2,
	1167, 1168, 5, 276, 139, 2, 1168, 273, 3, 2, 2, 2, 1169, 1170, 7, 9, 2,
	2, 1170, 1172, 5, 274, 138, 2, 1171, 1169, 3, 2, 2, 2, 1171, 1172, 3, 2,
	2, 2, 1172, 275, 3, 2, 2, 2, 1173, 1178, 7, 106, 2, 2, 1174, 1175, 7, 9,
	2, 2, 1175, 1177, 7, 106, 2, 2, 1176, 1174, 3, 2, 2, 2, 1177, 1180, 3,
	2, 2, 2, 1178, 1176, 3, 2, 2, 2, 1178, 1179, 3, 2, 2, 2, 1179, 277, 3,
	2, 2, 2, 1180, 1178, 3, 2, 2, 2, 1181, 1182, 7, 34, 2, 2, 1182, 1183, 7,
	32, 2, 2, 1183, 279, 3, 2, 2, 2, 1184, 1185, 7, 31, 2, 2, 1185, 1186, 7,
	32, 2, 2, 1186, 1191, 3, 2, 2, 2, 1187, 1188, 7, 21, 2, 2, 1188, 1189,
	5, 282, 142, 2, 1189, 1190, 7, 22, 2, 2, 1190, 1192, 3, 2, 2, 2, 1191,
	1187, 3, 2, 2, 2, 1191, 1192, 3, 2, 2, 2, 1192, 281, 3, 2, 2, 2, 1193,
	1198, 5, 284, 143, 2, 1194, 1195, 7, 23, 2, 2, 1195, 1197, 5, 284, 143,
	2, 1196, 1194, 3, 2, 2, 2, 1197, 1200, 3, 2, 2, 2, 1198, 1196, 3, 2, 2,
	2, 1198, 1199, 3, 2, 2, 2, 1199, 283, 3, 2, 2, 2, 1200, 1198, 3, 2, 2,
	2, 1201, 1202, 7, 106, 2, 2, 1202, 1205, 7, 24, 2, 2, 1203, 1206, 7, 100,
	2, 2, 1204, 1206, 5, 248, 125, 2, 1205, 1203, 3, 2, 2, 2, 1205, 1204, 3,
	2, 2, 2, 1206, 1207, 3, 2, 2, 2, 1207, 1208, 7, 25, 2, 2, 1208, 285, 3,
	2, 2, 2, 1209, 1210, 9, 7, 2, 2, 1210, 287, 3, 2, 2, 2, 139, 296, 300,
	312, 316, 322, 331, 334, 340, 343, 349, 366, 372, 378, 386, 394, 400, 404,
	414, 416, 424, 426, 435, 442, 447, 451, 458, 463, 472, 478, 482, 487, 497,
	504, 506, 514, 522, 528, 532, 539, 543, 548, 563, 568, 578, 584, 590, 596,
	606, 610, 613, 616, 618, 625, 627, 634, 636, 638, 643, 648, 654, 657, 662,
	668, 674, 679, 683, 690, 701, 703, 708, 710, 720, 732, 734, 743, 751, 763,
	774, 778, 782, 785, 789, 793, 799, 805, 811, 816, 822, 827, 838, 843, 857,
	869, 876, 881, 888, 891, 896, 902, 912, 920, 928, 945, 957, 967, 975, 978,
	981, 985, 994, 1009, 1013, 1020, 1025, 1039, 1054, 1058, 1060, 1069, 1075,
	1081, 1089, 1094, 1102, 1109, 1120, 1129, 1136, 1146, 1155, 1160, 1165,
	1171, 1178, 1191, 1198, 1205,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'@'", "'*'", "'::='", "'BOOLEAN'", "'TRUE'", "'FALSE'", "'.'", "'..'",
	"'...'", "'''", "'&'", "'<'", "'>'", "'</'", "'/>'", "'true'", "'false'",
	"'INTEGER'", "'{'", "'}'", "','", "'('", "')'", "'-'", "'ENUMERATED'",
	"'REAL'", "'PLUS-INFINITY'", "'MINUS-INFINITY'", "'BIT'", "'STRING'", "'CONTAINING'",
	"'OCTET'", "'NULL'", "'SEQUENCE'", "'OPTIONAL'", "'DEFAULT'", "'COMPONENTS'",
	"'OF'", "'SET'", "'!'", "'ALL'", "'EXCEPT'", "'^'", "'|'", "'UNION'", "'INTERSECTION'",
	"'INCLUDES'", "'MIN'", "'MAX'", "'SIZE'", "'FROM'", "'WITH'", "'COMPONENT'",
	"'PRESENT'", "'ABSENT'", "'PATTERN'", "'TYPE-Identifier'", "'ABSTRACT-SYNTAX'",
	"'CLASS'", "'UNIQUE'", "'SYNTAX'", "'['", "']'", "'INSTANCE'", "';'", "'IMPORTS'",
	"'EXPORTS'", "'EXTENSIBILITY'", "'IMPLIED'", "'EXPLICIT'", "'TAGS'", "'IMPLICIT'",
	"'AUTOMATIC'", "'DEFINITIONS'", "'BEGIN'", "'END'", "'[['", "']]'", "':'",
	"'CHOICE'", "'UNIVERSAL'", "'APPLICATION'", "'PRIVATE'", "'EMBEDDED'",
	"'PDV'", "'EXTERNAL'", "'OBJECT'", "'IDENTIFIER'", "'RELATIVE-OID'", "'CHARACTER'",
	"'CONSTRAINED'", "'BY'", "'@.'", "'ENCODED'", "'--'",
}
var symbolicNames = []string{
	"", "A_ROND", "STAR", "ASSIGN_OP", "BOOLEAN_LITERAL", "TRUE_LITERAL", "FALSE_LITERAL",
	"DOT", "DOUBLE_DOT", "ELLIPSIS", "APOSTROPHE", "AMPERSAND", "LESS_THAN",
	"GREATER_THAN", "LESS_THAN_SLASH", "SLASH_GREATER_THAN", "TRUE_SMALL_LITERAL",
	"FALSE_SMALL_LITERAL", "INTEGER_LITERAL", "L_BRACE", "R_BRACE", "COMMA",
	"L_PARAN", "R_PARAN", "MINUS", "ENUMERATED_LITERAL", "REAL_LITERAL", "PLUS_INFINITY_LITERAL",
	"MINUS_INFINITY_LITERAL", "BIT_LITERAL", "STRING_LITERAL", "CONTAINING_LITERAL",
	"OCTET_LITERAL", "NULL_LITERAL", "SEQUENCE_LITERAL", "OPTIONAL_LITERAL",
	"DEFAULT_LITERAL", "COMPONENTS_LITERAL", "OF_LITERAL", "SET_LITERAL", "EXCLAM",
	"ALL_LITERAL", "EXCEPT_LITERAL", "POWER", "PIPE", "UNION_LITERAL", "INTERSECTION_LITERAL",
	"INCLUDES_LITERAL", "MIN_LITERAL", "MAX_LITERAL", "SIZE_LITERAL", "FROM_LITERAL",
	"WITH_LITERAL", "COMPONENT_LITERAL", "PRESENT_LITERAL", "ABSENT_LITERAL",
	"PATTERN_LITERAL", "TYPE_IDENTIFIER_LITERAL", "ABSTRACT_SYNTAX_LITERAL",
	"CLASS_LITERAL", "UNIQUE_LITERAL", "SYNTAX_LITERAL", "L_BRACKET", "R_BRACKET",
	"INSTANCE_LITERAL", "SEMI_COLON", "IMPORTS_LITERAL", "EXPORTS_LITERAL",
	"EXTENSIBILITY_LITERAL", "IMPLIED_LITERAL", "EXPLICIT_LITERAL", "TAGS_LITERAL",
	"IMPLICIT_LITERAL", "AUTOMATIC_LITERAL", "DEFINITIONS_LITERAL", "BEGIN_LITERAL",
	"END_LITERAL", "DOUBLE_L_BRACKET", "DOUBLE_R_BRACKET", "COLON", "CHOICE_LITERAL",
	"UNIVERSAL_LITERAL", "APPLICATION_LITERAL", "PRIVATE_LITERAL", "EMBEDDED_LITERAL",
	"PDV_LITERAL", "EXTERNAL_LITERAL", "OBJECT_LITERAL", "IDENTIFIER_LITERAL",
	"RELATIVE_OID_LITERAL", "CHARACTER_LITERAL", "CONSTRAINED_LITERAL", "BY_LITERAL",
	"A_ROND_DOT", "ENCODED_LITERAL", "COMMENT", "UNRESTRICTEDCHARACTERSTRINGTYPE",
	"EXTENSTIONENDMARKER", "NUMBER", "WS", "LINE_COMMENT", "BSTRING", "HSTRING",
	"CSTRING", "IDENTIFIER",
}

var ruleNames = []string{
	"moduleDefinition", "tagDefault", "extensionDefault", "moduleBody", "exports",
	"symbolsExported", "imports", "symbolsImported", "symbolsFromModuleList",
	"symbolsFromModule", "globalModuleReference", "assignedIdentifier", "symbolList",
	"symbol", "assignmentList", "assignment", "sequenceType", "extensionAndException",
	"optionalExtensionMarker", "componentTypeLists", "rootComponentTypeList",
	"componentTypeList", "componentType", "extensionAdditions", "extensionAdditionList",
	"extensionAddition", "extensionAdditionGroup", "versionNumber", "sequenceOfType",
	"sizeConstraint", "parameterizedAssignment", "parameterList", "parameter",
	"paramGovernor", "governor", "objectClassAssignment", "objectClass", "definedObjectClass",
	"usefulObjectClassReference", "externalObjectClassReference", "objectClassDefn",
	"withSyntaxSpec", "syntaxList", "tokenOrGroupSpec", "optionalGroup", "requiredToken",
	"literal", "primitiveFieldName", "fieldSpec", "typeFieldSpec", "typeOptionalitySpec",
	"fixedTypeValueFieldSpec", "valueOptionalitySpec", "variableTypeValueFieldSpec",
	"fixedTypeValueSetFieldSpec", "valueSetOptionalitySpec", "object", "parameterizedObject",
	"definedObject", "objectSet", "objectSetSpec", "fieldName", "valueSet",
	"elementSetSpecs", "rootElementSetSpec", "additionalElementSetSpec", "elementSetSpec",
	"unions", "exclusions", "intersections", "unionMark", "intersectionMark",
	"elements", "objectSetElements", "intersectionElements", "subtypeElements",
	"variableTypeValueSetFieldSpec", "objectFieldSpec", "objectOptionalitySpec",
	"objectSetFieldSpec", "objectSetOptionalitySpec", "typeAssignment", "valueAssignment",
	"asnType", "builtinType", "objectClassFieldType", "setType", "setOfType",
	"referencedType", "definedType", "constraint", "constraintSpec", "userDefinedConstraint",
	"generalConstraint", "userDefinedConstraintParameter", "tableConstraint",
	"simpleTableConstraint", "contentsConstraint", "subtypeConstraint", "value",
	"builtinValue", "objectIdentifierValue", "objIdComponentsList", "objIdComponents",
	"integerValue", "choiceValue", "enumeratedValue", "signedNumber", "choiceType",
	"alternativeTypeLists", "extensionAdditionAlternatives", "extensionAdditionAlternativesList",
	"extensionAdditionAlternative", "extensionAdditionAlternativesGroup", "rootAlternativeTypeList",
	"alternativeTypeList", "namedType", "enumeratedType", "enumerations", "rootEnumeration",
	"enumeration", "enumerationItem", "namedNumber", "definedValue", "parameterizedValue",
	"simpleDefinedValue", "actualParameterList", "actualParameter", "exceptionSpec",
	"exceptionIdentification", "additionalEnumeration", "integerType", "namedNumberList",
	"objectidentifiertype", "componentRelationConstraint", "atNotation", "level",
	"componentIdList", "octetStringType", "bitStringType", "namedBitList",
	"namedBit", "booleanValue",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type ASNParser struct {
	*antlr.BaseParser
}

func NewASNParser(input antlr.TokenStream) *ASNParser {
	this := new(ASNParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ASN.g4"

	return this
}

// ASNParser tokens.
const (
	ASNParserEOF                             = antlr.TokenEOF
	ASNParserA_ROND                          = 1
	ASNParserSTAR                            = 2
	ASNParserASSIGN_OP                       = 3
	ASNParserBOOLEAN_LITERAL                 = 4
	ASNParserTRUE_LITERAL                    = 5
	ASNParserFALSE_LITERAL                   = 6
	ASNParserDOT                             = 7
	ASNParserDOUBLE_DOT                      = 8
	ASNParserELLIPSIS                        = 9
	ASNParserAPOSTROPHE                      = 10
	ASNParserAMPERSAND                       = 11
	ASNParserLESS_THAN                       = 12
	ASNParserGREATER_THAN                    = 13
	ASNParserLESS_THAN_SLASH                 = 14
	ASNParserSLASH_GREATER_THAN              = 15
	ASNParserTRUE_SMALL_LITERAL              = 16
	ASNParserFALSE_SMALL_LITERAL             = 17
	ASNParserINTEGER_LITERAL                 = 18
	ASNParserL_BRACE                         = 19
	ASNParserR_BRACE                         = 20
	ASNParserCOMMA                           = 21
	ASNParserL_PARAN                         = 22
	ASNParserR_PARAN                         = 23
	ASNParserMINUS                           = 24
	ASNParserENUMERATED_LITERAL              = 25
	ASNParserREAL_LITERAL                    = 26
	ASNParserPLUS_INFINITY_LITERAL           = 27
	ASNParserMINUS_INFINITY_LITERAL          = 28
	ASNParserBIT_LITERAL                     = 29
	ASNParserSTRING_LITERAL                  = 30
	ASNParserCONTAINING_LITERAL              = 31
	ASNParserOCTET_LITERAL                   = 32
	ASNParserNULL_LITERAL                    = 33
	ASNParserSEQUENCE_LITERAL                = 34
	ASNParserOPTIONAL_LITERAL                = 35
	ASNParserDEFAULT_LITERAL                 = 36
	ASNParserCOMPONENTS_LITERAL              = 37
	ASNParserOF_LITERAL                      = 38
	ASNParserSET_LITERAL                     = 39
	ASNParserEXCLAM                          = 40
	ASNParserALL_LITERAL                     = 41
	ASNParserEXCEPT_LITERAL                  = 42
	ASNParserPOWER                           = 43
	ASNParserPIPE                            = 44
	ASNParserUNION_LITERAL                   = 45
	ASNParserINTERSECTION_LITERAL            = 46
	ASNParserINCLUDES_LITERAL                = 47
	ASNParserMIN_LITERAL                     = 48
	ASNParserMAX_LITERAL                     = 49
	ASNParserSIZE_LITERAL                    = 50
	ASNParserFROM_LITERAL                    = 51
	ASNParserWITH_LITERAL                    = 52
	ASNParserCOMPONENT_LITERAL               = 53
	ASNParserPRESENT_LITERAL                 = 54
	ASNParserABSENT_LITERAL                  = 55
	ASNParserPATTERN_LITERAL                 = 56
	ASNParserTYPE_IDENTIFIER_LITERAL         = 57
	ASNParserABSTRACT_SYNTAX_LITERAL         = 58
	ASNParserCLASS_LITERAL                   = 59
	ASNParserUNIQUE_LITERAL                  = 60
	ASNParserSYNTAX_LITERAL                  = 61
	ASNParserL_BRACKET                       = 62
	ASNParserR_BRACKET                       = 63
	ASNParserINSTANCE_LITERAL                = 64
	ASNParserSEMI_COLON                      = 65
	ASNParserIMPORTS_LITERAL                 = 66
	ASNParserEXPORTS_LITERAL                 = 67
	ASNParserEXTENSIBILITY_LITERAL           = 68
	ASNParserIMPLIED_LITERAL                 = 69
	ASNParserEXPLICIT_LITERAL                = 70
	ASNParserTAGS_LITERAL                    = 71
	ASNParserIMPLICIT_LITERAL                = 72
	ASNParserAUTOMATIC_LITERAL               = 73
	ASNParserDEFINITIONS_LITERAL             = 74
	ASNParserBEGIN_LITERAL                   = 75
	ASNParserEND_LITERAL                     = 76
	ASNParserDOUBLE_L_BRACKET                = 77
	ASNParserDOUBLE_R_BRACKET                = 78
	ASNParserCOLON                           = 79
	ASNParserCHOICE_LITERAL                  = 80
	ASNParserUNIVERSAL_LITERAL               = 81
	ASNParserAPPLICATION_LITERAL             = 82
	ASNParserPRIVATE_LITERAL                 = 83
	ASNParserEMBEDDED_LITERAL                = 84
	ASNParserPDV_LITERAL                     = 85
	ASNParserEXTERNAL_LITERAL                = 86
	ASNParserOBJECT_LITERAL                  = 87
	ASNParserIDENTIFIER_LITERAL              = 88
	ASNParserRELATIVE_OID_LITERAL            = 89
	ASNParserCHARACTER_LITERAL               = 90
	ASNParserCONSTRAINED_LITERAL             = 91
	ASNParserBY_LITERAL                      = 92
	ASNParserA_ROND_DOT                      = 93
	ASNParserENCODED_LITERAL                 = 94
	ASNParserCOMMENT                         = 95
	ASNParserUNRESTRICTEDCHARACTERSTRINGTYPE = 96
	ASNParserEXTENSTIONENDMARKER             = 97
	ASNParserNUMBER                          = 98
	ASNParserWS                              = 99
	ASNParserLINE_COMMENT                    = 100
	ASNParserBSTRING                         = 101
	ASNParserHSTRING                         = 102
	ASNParserCSTRING                         = 103
	ASNParserIDENTIFIER                      = 104
)

// ASNParser rules.
const (
	ASNParserRULE_moduleDefinition                   = 0
	ASNParserRULE_tagDefault                         = 1
	ASNParserRULE_extensionDefault                   = 2
	ASNParserRULE_moduleBody                         = 3
	ASNParserRULE_exports                            = 4
	ASNParserRULE_symbolsExported                    = 5
	ASNParserRULE_imports                            = 6
	ASNParserRULE_symbolsImported                    = 7
	ASNParserRULE_symbolsFromModuleList              = 8
	ASNParserRULE_symbolsFromModule                  = 9
	ASNParserRULE_globalModuleReference              = 10
	ASNParserRULE_assignedIdentifier                 = 11
	ASNParserRULE_symbolList                         = 12
	ASNParserRULE_symbol                             = 13
	ASNParserRULE_assignmentList                     = 14
	ASNParserRULE_assignment                         = 15
	ASNParserRULE_sequenceType                       = 16
	ASNParserRULE_extensionAndException              = 17
	ASNParserRULE_optionalExtensionMarker            = 18
	ASNParserRULE_componentTypeLists                 = 19
	ASNParserRULE_rootComponentTypeList              = 20
	ASNParserRULE_componentTypeList                  = 21
	ASNParserRULE_componentType                      = 22
	ASNParserRULE_extensionAdditions                 = 23
	ASNParserRULE_extensionAdditionList              = 24
	ASNParserRULE_extensionAddition                  = 25
	ASNParserRULE_extensionAdditionGroup             = 26
	ASNParserRULE_versionNumber                      = 27
	ASNParserRULE_sequenceOfType                     = 28
	ASNParserRULE_sizeConstraint                     = 29
	ASNParserRULE_parameterizedAssignment            = 30
	ASNParserRULE_parameterList                      = 31
	ASNParserRULE_parameter                          = 32
	ASNParserRULE_paramGovernor                      = 33
	ASNParserRULE_governor                           = 34
	ASNParserRULE_objectClassAssignment              = 35
	ASNParserRULE_objectClass                        = 36
	ASNParserRULE_definedObjectClass                 = 37
	ASNParserRULE_usefulObjectClassReference         = 38
	ASNParserRULE_externalObjectClassReference       = 39
	ASNParserRULE_objectClassDefn                    = 40
	ASNParserRULE_withSyntaxSpec                     = 41
	ASNParserRULE_syntaxList                         = 42
	ASNParserRULE_tokenOrGroupSpec                   = 43
	ASNParserRULE_optionalGroup                      = 44
	ASNParserRULE_requiredToken                      = 45
	ASNParserRULE_literal                            = 46
	ASNParserRULE_primitiveFieldName                 = 47
	ASNParserRULE_fieldSpec                          = 48
	ASNParserRULE_typeFieldSpec                      = 49
	ASNParserRULE_typeOptionalitySpec                = 50
	ASNParserRULE_fixedTypeValueFieldSpec            = 51
	ASNParserRULE_valueOptionalitySpec               = 52
	ASNParserRULE_variableTypeValueFieldSpec         = 53
	ASNParserRULE_fixedTypeValueSetFieldSpec         = 54
	ASNParserRULE_valueSetOptionalitySpec            = 55
	ASNParserRULE_object                             = 56
	ASNParserRULE_parameterizedObject                = 57
	ASNParserRULE_definedObject                      = 58
	ASNParserRULE_objectSet                          = 59
	ASNParserRULE_objectSetSpec                      = 60
	ASNParserRULE_fieldName                          = 61
	ASNParserRULE_valueSet                           = 62
	ASNParserRULE_elementSetSpecs                    = 63
	ASNParserRULE_rootElementSetSpec                 = 64
	ASNParserRULE_additionalElementSetSpec           = 65
	ASNParserRULE_elementSetSpec                     = 66
	ASNParserRULE_unions                             = 67
	ASNParserRULE_exclusions                         = 68
	ASNParserRULE_intersections                      = 69
	ASNParserRULE_unionMark                          = 70
	ASNParserRULE_intersectionMark                   = 71
	ASNParserRULE_elements                           = 72
	ASNParserRULE_objectSetElements                  = 73
	ASNParserRULE_intersectionElements               = 74
	ASNParserRULE_subtypeElements                    = 75
	ASNParserRULE_variableTypeValueSetFieldSpec      = 76
	ASNParserRULE_objectFieldSpec                    = 77
	ASNParserRULE_objectOptionalitySpec              = 78
	ASNParserRULE_objectSetFieldSpec                 = 79
	ASNParserRULE_objectSetOptionalitySpec           = 80
	ASNParserRULE_typeAssignment                     = 81
	ASNParserRULE_valueAssignment                    = 82
	ASNParserRULE_asnType                            = 83
	ASNParserRULE_builtinType                        = 84
	ASNParserRULE_objectClassFieldType               = 85
	ASNParserRULE_setType                            = 86
	ASNParserRULE_setOfType                          = 87
	ASNParserRULE_referencedType                     = 88
	ASNParserRULE_definedType                        = 89
	ASNParserRULE_constraint                         = 90
	ASNParserRULE_constraintSpec                     = 91
	ASNParserRULE_userDefinedConstraint              = 92
	ASNParserRULE_generalConstraint                  = 93
	ASNParserRULE_userDefinedConstraintParameter     = 94
	ASNParserRULE_tableConstraint                    = 95
	ASNParserRULE_simpleTableConstraint              = 96
	ASNParserRULE_contentsConstraint                 = 97
	ASNParserRULE_subtypeConstraint                  = 98
	ASNParserRULE_value                              = 99
	ASNParserRULE_builtinValue                       = 100
	ASNParserRULE_objectIdentifierValue              = 101
	ASNParserRULE_objIdComponentsList                = 102
	ASNParserRULE_objIdComponents                    = 103
	ASNParserRULE_integerValue                       = 104
	ASNParserRULE_choiceValue                        = 105
	ASNParserRULE_enumeratedValue                    = 106
	ASNParserRULE_signedNumber                       = 107
	ASNParserRULE_choiceType                         = 108
	ASNParserRULE_alternativeTypeLists               = 109
	ASNParserRULE_extensionAdditionAlternatives      = 110
	ASNParserRULE_extensionAdditionAlternativesList  = 111
	ASNParserRULE_extensionAdditionAlternative       = 112
	ASNParserRULE_extensionAdditionAlternativesGroup = 113
	ASNParserRULE_rootAlternativeTypeList            = 114
	ASNParserRULE_alternativeTypeList                = 115
	ASNParserRULE_namedType                          = 116
	ASNParserRULE_enumeratedType                     = 117
	ASNParserRULE_enumerations                       = 118
	ASNParserRULE_rootEnumeration                    = 119
	ASNParserRULE_enumeration                        = 120
	ASNParserRULE_enumerationItem                    = 121
	ASNParserRULE_namedNumber                        = 122
	ASNParserRULE_definedValue                       = 123
	ASNParserRULE_parameterizedValue                 = 124
	ASNParserRULE_simpleDefinedValue                 = 125
	ASNParserRULE_actualParameterList                = 126
	ASNParserRULE_actualParameter                    = 127
	ASNParserRULE_exceptionSpec                      = 128
	ASNParserRULE_exceptionIdentification            = 129
	ASNParserRULE_additionalEnumeration              = 130
	ASNParserRULE_integerType                        = 131
	ASNParserRULE_namedNumberList                    = 132
	ASNParserRULE_objectidentifiertype               = 133
	ASNParserRULE_componentRelationConstraint        = 134
	ASNParserRULE_atNotation                         = 135
	ASNParserRULE_level                              = 136
	ASNParserRULE_componentIdList                    = 137
	ASNParserRULE_octetStringType                    = 138
	ASNParserRULE_bitStringType                      = 139
	ASNParserRULE_namedBitList                       = 140
	ASNParserRULE_namedBit                           = 141
	ASNParserRULE_booleanValue                       = 142
)

// IModuleDefinitionContext is an interface to support dynamic dispatch.
type IModuleDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleDefinitionContext differentiates from other interfaces.
	IsModuleDefinitionContext()
}

type ModuleDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDefinitionContext() *ModuleDefinitionContext {
	var p = new(ModuleDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_moduleDefinition
	return p
}

func (*ModuleDefinitionContext) IsModuleDefinitionContext() {}

func NewModuleDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDefinitionContext {
	var p = new(ModuleDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_moduleDefinition

	return p
}

func (s *ModuleDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDefinitionContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *ModuleDefinitionContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *ModuleDefinitionContext) DEFINITIONS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFINITIONS_LITERAL, 0)
}

func (s *ModuleDefinitionContext) TagDefault() ITagDefaultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITagDefaultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITagDefaultContext)
}

func (s *ModuleDefinitionContext) ExtensionDefault() IExtensionDefaultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionDefaultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionDefaultContext)
}

func (s *ModuleDefinitionContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASNParserASSIGN_OP, 0)
}

func (s *ModuleDefinitionContext) BEGIN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserBEGIN_LITERAL, 0)
}

func (s *ModuleDefinitionContext) ModuleBody() IModuleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleBodyContext)
}

func (s *ModuleDefinitionContext) END_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserEND_LITERAL, 0)
}

func (s *ModuleDefinitionContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ModuleDefinitionContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ModuleDefinitionContext) AllL_PARAN() []antlr.TerminalNode {
	return s.GetTokens(ASNParserL_PARAN)
}

func (s *ModuleDefinitionContext) L_PARAN(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, i)
}

func (s *ModuleDefinitionContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserNUMBER)
}

func (s *ModuleDefinitionContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserNUMBER, i)
}

func (s *ModuleDefinitionContext) AllR_PARAN() []antlr.TerminalNode {
	return s.GetTokens(ASNParserR_PARAN)
}

func (s *ModuleDefinitionContext) R_PARAN(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, i)
}

func (s *ModuleDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterModuleDefinition(s)
	}
}

func (s *ModuleDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitModuleDefinition(s)
	}
}

func (s *ModuleDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitModuleDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ModuleDefinition() (localctx IModuleDefinitionContext) {
	localctx = NewModuleDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ASNParserRULE_moduleDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(286)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(298)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserL_BRACE {
		{
			p.SetState(287)
			p.Match(ASNParserL_BRACE)
		}
		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ASNParserIDENTIFIER {
			{
				p.SetState(288)
				p.Match(ASNParserIDENTIFIER)
			}
			{
				p.SetState(289)
				p.Match(ASNParserL_PARAN)
			}
			{
				p.SetState(290)
				p.Match(ASNParserNUMBER)
			}
			{
				p.SetState(291)
				p.Match(ASNParserR_PARAN)
			}

			p.SetState(296)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(297)
			p.Match(ASNParserR_BRACE)
		}

	}
	{
		p.SetState(300)
		p.Match(ASNParserDEFINITIONS_LITERAL)
	}
	{
		p.SetState(301)
		p.TagDefault()
	}
	{
		p.SetState(302)
		p.ExtensionDefault()
	}
	{
		p.SetState(303)
		p.Match(ASNParserASSIGN_OP)
	}
	{
		p.SetState(304)
		p.Match(ASNParserBEGIN_LITERAL)
	}
	{
		p.SetState(305)
		p.ModuleBody()
	}
	{
		p.SetState(306)
		p.Match(ASNParserEND_LITERAL)
	}

	return localctx
}

// ITagDefaultContext is an interface to support dynamic dispatch.
type ITagDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTagDefaultContext differentiates from other interfaces.
	IsTagDefaultContext()
}

type TagDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagDefaultContext() *TagDefaultContext {
	var p = new(TagDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_tagDefault
	return p
}

func (*TagDefaultContext) IsTagDefaultContext() {}

func NewTagDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagDefaultContext {
	var p = new(TagDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_tagDefault

	return p
}

func (s *TagDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *TagDefaultContext) TAGS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserTAGS_LITERAL, 0)
}

func (s *TagDefaultContext) EXPLICIT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserEXPLICIT_LITERAL, 0)
}

func (s *TagDefaultContext) IMPLICIT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserIMPLICIT_LITERAL, 0)
}

func (s *TagDefaultContext) AUTOMATIC_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserAUTOMATIC_LITERAL, 0)
}

func (s *TagDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTagDefault(s)
	}
}

func (s *TagDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTagDefault(s)
	}
}

func (s *TagDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitTagDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) TagDefault() (localctx ITagDefaultContext) {
	localctx = NewTagDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ASNParserRULE_tagDefault)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(ASNParserEXPLICIT_LITERAL-70))|(1<<(ASNParserIMPLICIT_LITERAL-70))|(1<<(ASNParserAUTOMATIC_LITERAL-70)))) != 0 {
		{
			p.SetState(308)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(ASNParserEXPLICIT_LITERAL-70))|(1<<(ASNParserIMPLICIT_LITERAL-70))|(1<<(ASNParserAUTOMATIC_LITERAL-70)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(309)
			p.Match(ASNParserTAGS_LITERAL)
		}

	}

	return localctx
}

// IExtensionDefaultContext is an interface to support dynamic dispatch.
type IExtensionDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionDefaultContext differentiates from other interfaces.
	IsExtensionDefaultContext()
}

type ExtensionDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionDefaultContext() *ExtensionDefaultContext {
	var p = new(ExtensionDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionDefault
	return p
}

func (*ExtensionDefaultContext) IsExtensionDefaultContext() {}

func NewExtensionDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionDefaultContext {
	var p = new(ExtensionDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionDefault

	return p
}

func (s *ExtensionDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionDefaultContext) EXTENSIBILITY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserEXTENSIBILITY_LITERAL, 0)
}

func (s *ExtensionDefaultContext) IMPLIED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserIMPLIED_LITERAL, 0)
}

func (s *ExtensionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionDefault(s)
	}
}

func (s *ExtensionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionDefault(s)
	}
}

func (s *ExtensionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExtensionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExtensionDefault() (localctx IExtensionDefaultContext) {
	localctx = NewExtensionDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ASNParserRULE_extensionDefault)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserEXTENSIBILITY_LITERAL {
		{
			p.SetState(312)
			p.Match(ASNParserEXTENSIBILITY_LITERAL)
		}
		{
			p.SetState(313)
			p.Match(ASNParserIMPLIED_LITERAL)
		}

	}

	return localctx
}

// IModuleBodyContext is an interface to support dynamic dispatch.
type IModuleBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleBodyContext differentiates from other interfaces.
	IsModuleBodyContext()
}

type ModuleBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleBodyContext() *ModuleBodyContext {
	var p = new(ModuleBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_moduleBody
	return p
}

func (*ModuleBodyContext) IsModuleBodyContext() {}

func NewModuleBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleBodyContext {
	var p = new(ModuleBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_moduleBody

	return p
}

func (s *ModuleBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleBodyContext) Exports() IExportsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExportsContext)
}

func (s *ModuleBodyContext) Imports() IImportsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportsContext)
}

func (s *ModuleBodyContext) AssignmentList() IAssignmentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *ModuleBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterModuleBody(s)
	}
}

func (s *ModuleBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitModuleBody(s)
	}
}

func (s *ModuleBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitModuleBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ModuleBody() (localctx IModuleBodyContext) {
	localctx = NewModuleBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ASNParserRULE_moduleBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserIMPORTS_LITERAL || _la == ASNParserEXPORTS_LITERAL || _la == ASNParserIDENTIFIER {
		{
			p.SetState(316)
			p.Exports()
		}
		{
			p.SetState(317)
			p.Imports()
		}
		{
			p.SetState(318)
			p.AssignmentList()
		}

	}

	return localctx
}

// IExportsContext is an interface to support dynamic dispatch.
type IExportsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportsContext differentiates from other interfaces.
	IsExportsContext()
}

type ExportsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportsContext() *ExportsContext {
	var p = new(ExportsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_exports
	return p
}

func (*ExportsContext) IsExportsContext() {}

func NewExportsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportsContext {
	var p = new(ExportsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_exports

	return p
}

func (s *ExportsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportsContext) EXPORTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserEXPORTS_LITERAL, 0)
}

func (s *ExportsContext) SymbolsExported() ISymbolsExportedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsExportedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolsExportedContext)
}

func (s *ExportsContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserSEMI_COLON, 0)
}

func (s *ExportsContext) ALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserALL_LITERAL, 0)
}

func (s *ExportsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExports(s)
	}
}

func (s *ExportsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExports(s)
	}
}

func (s *ExportsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExports(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Exports() (localctx IExportsContext) {
	localctx = NewExportsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ASNParserRULE_exports)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(329)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(322)
			p.Match(ASNParserEXPORTS_LITERAL)
		}
		{
			p.SetState(323)
			p.SymbolsExported()
		}
		{
			p.SetState(324)
			p.Match(ASNParserSEMI_COLON)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(326)
			p.Match(ASNParserEXPORTS_LITERAL)
		}
		{
			p.SetState(327)
			p.Match(ASNParserALL_LITERAL)
		}
		{
			p.SetState(328)
			p.Match(ASNParserSEMI_COLON)
		}

	}

	return localctx
}

// ISymbolsExportedContext is an interface to support dynamic dispatch.
type ISymbolsExportedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsExportedContext differentiates from other interfaces.
	IsSymbolsExportedContext()
}

type SymbolsExportedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsExportedContext() *SymbolsExportedContext {
	var p = new(SymbolsExportedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbolsExported
	return p
}

func (*SymbolsExportedContext) IsSymbolsExportedContext() {}

func NewSymbolsExportedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsExportedContext {
	var p = new(SymbolsExportedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbolsExported

	return p
}

func (s *SymbolsExportedContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsExportedContext) SymbolList() ISymbolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolListContext)
}

func (s *SymbolsExportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsExportedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsExportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbolsExported(s)
	}
}

func (s *SymbolsExportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbolsExported(s)
	}
}

func (s *SymbolsExportedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSymbolsExported(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SymbolsExported() (localctx ISymbolsExportedContext) {
	localctx = NewSymbolsExportedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ASNParserRULE_symbolsExported)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserIDENTIFIER {
		{
			p.SetState(331)
			p.SymbolList()
		}

	}

	return localctx
}

// IImportsContext is an interface to support dynamic dispatch.
type IImportsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportsContext differentiates from other interfaces.
	IsImportsContext()
}

type ImportsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportsContext() *ImportsContext {
	var p = new(ImportsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_imports
	return p
}

func (*ImportsContext) IsImportsContext() {}

func NewImportsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportsContext {
	var p = new(ImportsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_imports

	return p
}

func (s *ImportsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportsContext) IMPORTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserIMPORTS_LITERAL, 0)
}

func (s *ImportsContext) SymbolsImported() ISymbolsImportedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsImportedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolsImportedContext)
}

func (s *ImportsContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserSEMI_COLON, 0)
}

func (s *ImportsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterImports(s)
	}
}

func (s *ImportsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitImports(s)
	}
}

func (s *ImportsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitImports(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Imports() (localctx IImportsContext) {
	localctx = NewImportsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ASNParserRULE_imports)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserIMPORTS_LITERAL {
		{
			p.SetState(334)
			p.Match(ASNParserIMPORTS_LITERAL)
		}
		{
			p.SetState(335)
			p.SymbolsImported()
		}
		{
			p.SetState(336)
			p.Match(ASNParserSEMI_COLON)
		}

	}

	return localctx
}

// ISymbolsImportedContext is an interface to support dynamic dispatch.
type ISymbolsImportedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsImportedContext differentiates from other interfaces.
	IsSymbolsImportedContext()
}

type SymbolsImportedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsImportedContext() *SymbolsImportedContext {
	var p = new(SymbolsImportedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbolsImported
	return p
}

func (*SymbolsImportedContext) IsSymbolsImportedContext() {}

func NewSymbolsImportedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsImportedContext {
	var p = new(SymbolsImportedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbolsImported

	return p
}

func (s *SymbolsImportedContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsImportedContext) SymbolsFromModuleList() ISymbolsFromModuleListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsFromModuleListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolsFromModuleListContext)
}

func (s *SymbolsImportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsImportedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsImportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbolsImported(s)
	}
}

func (s *SymbolsImportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbolsImported(s)
	}
}

func (s *SymbolsImportedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSymbolsImported(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SymbolsImported() (localctx ISymbolsImportedContext) {
	localctx = NewSymbolsImportedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ASNParserRULE_symbolsImported)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(341)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserIDENTIFIER {
		{
			p.SetState(340)
			p.SymbolsFromModuleList()
		}

	}

	return localctx
}

// ISymbolsFromModuleListContext is an interface to support dynamic dispatch.
type ISymbolsFromModuleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsFromModuleListContext differentiates from other interfaces.
	IsSymbolsFromModuleListContext()
}

type SymbolsFromModuleListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsFromModuleListContext() *SymbolsFromModuleListContext {
	var p = new(SymbolsFromModuleListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbolsFromModuleList
	return p
}

func (*SymbolsFromModuleListContext) IsSymbolsFromModuleListContext() {}

func NewSymbolsFromModuleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsFromModuleListContext {
	var p = new(SymbolsFromModuleListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbolsFromModuleList

	return p
}

func (s *SymbolsFromModuleListContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsFromModuleListContext) AllSymbolsFromModule() []ISymbolsFromModuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolsFromModuleContext)(nil)).Elem())
	var tst = make([]ISymbolsFromModuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolsFromModuleContext)
		}
	}

	return tst
}

func (s *SymbolsFromModuleListContext) SymbolsFromModule(i int) ISymbolsFromModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsFromModuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolsFromModuleContext)
}

func (s *SymbolsFromModuleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsFromModuleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsFromModuleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbolsFromModuleList(s)
	}
}

func (s *SymbolsFromModuleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbolsFromModuleList(s)
	}
}

func (s *SymbolsFromModuleListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSymbolsFromModuleList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SymbolsFromModuleList() (localctx ISymbolsFromModuleListContext) {
	localctx = NewSymbolsFromModuleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ASNParserRULE_symbolsFromModuleList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(343)
		p.SymbolsFromModule()
	}

	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserIDENTIFIER {
		{
			p.SetState(344)
			p.SymbolsFromModule()
		}

		p.SetState(349)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISymbolsFromModuleContext is an interface to support dynamic dispatch.
type ISymbolsFromModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsFromModuleContext differentiates from other interfaces.
	IsSymbolsFromModuleContext()
}

type SymbolsFromModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsFromModuleContext() *SymbolsFromModuleContext {
	var p = new(SymbolsFromModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbolsFromModule
	return p
}

func (*SymbolsFromModuleContext) IsSymbolsFromModuleContext() {}

func NewSymbolsFromModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsFromModuleContext {
	var p = new(SymbolsFromModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbolsFromModule

	return p
}

func (s *SymbolsFromModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsFromModuleContext) SymbolList() ISymbolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolListContext)
}

func (s *SymbolsFromModuleContext) FROM_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserFROM_LITERAL, 0)
}

func (s *SymbolsFromModuleContext) GlobalModuleReference() IGlobalModuleReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalModuleReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalModuleReferenceContext)
}

func (s *SymbolsFromModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsFromModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsFromModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbolsFromModule(s)
	}
}

func (s *SymbolsFromModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbolsFromModule(s)
	}
}

func (s *SymbolsFromModuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSymbolsFromModule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SymbolsFromModule() (localctx ISymbolsFromModuleContext) {
	localctx = NewSymbolsFromModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ASNParserRULE_symbolsFromModule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.SymbolList()
	}
	{
		p.SetState(351)
		p.Match(ASNParserFROM_LITERAL)
	}
	{
		p.SetState(352)
		p.GlobalModuleReference()
	}

	return localctx
}

// IGlobalModuleReferenceContext is an interface to support dynamic dispatch.
type IGlobalModuleReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalModuleReferenceContext differentiates from other interfaces.
	IsGlobalModuleReferenceContext()
}

type GlobalModuleReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalModuleReferenceContext() *GlobalModuleReferenceContext {
	var p = new(GlobalModuleReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_globalModuleReference
	return p
}

func (*GlobalModuleReferenceContext) IsGlobalModuleReferenceContext() {}

func NewGlobalModuleReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalModuleReferenceContext {
	var p = new(GlobalModuleReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_globalModuleReference

	return p
}

func (s *GlobalModuleReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalModuleReferenceContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *GlobalModuleReferenceContext) AssignedIdentifier() IAssignedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignedIdentifierContext)
}

func (s *GlobalModuleReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalModuleReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalModuleReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterGlobalModuleReference(s)
	}
}

func (s *GlobalModuleReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitGlobalModuleReference(s)
	}
}

func (s *GlobalModuleReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitGlobalModuleReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) GlobalModuleReference() (localctx IGlobalModuleReferenceContext) {
	localctx = NewGlobalModuleReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ASNParserRULE_globalModuleReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(355)
		p.AssignedIdentifier()
	}

	return localctx
}

// IAssignedIdentifierContext is an interface to support dynamic dispatch.
type IAssignedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignedIdentifierContext differentiates from other interfaces.
	IsAssignedIdentifierContext()
}

type AssignedIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignedIdentifierContext() *AssignedIdentifierContext {
	var p = new(AssignedIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_assignedIdentifier
	return p
}

func (*AssignedIdentifierContext) IsAssignedIdentifierContext() {}

func NewAssignedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignedIdentifierContext {
	var p = new(AssignedIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_assignedIdentifier

	return p
}

func (s *AssignedIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *AssignedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAssignedIdentifier(s)
	}
}

func (s *AssignedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAssignedIdentifier(s)
	}
}

func (s *AssignedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitAssignedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) AssignedIdentifier() (localctx IAssignedIdentifierContext) {
	localctx = NewAssignedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ASNParserRULE_assignedIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// ISymbolListContext is an interface to support dynamic dispatch.
type ISymbolListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolListContext differentiates from other interfaces.
	IsSymbolListContext()
}

type SymbolListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolListContext() *SymbolListContext {
	var p = new(SymbolListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbolList
	return p
}

func (*SymbolListContext) IsSymbolListContext() {}

func NewSymbolListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolListContext {
	var p = new(SymbolListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbolList

	return p
}

func (s *SymbolListContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolListContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *SymbolListContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *SymbolListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *SymbolListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *SymbolListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbolList(s)
	}
}

func (s *SymbolListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbolList(s)
	}
}

func (s *SymbolListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSymbolList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SymbolList() (localctx ISymbolListContext) {
	localctx = NewSymbolListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ASNParserRULE_symbolList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.Symbol()
	}

	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(360)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(361)
			p.Symbol()
		}

		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISymbolContext is an interface to support dynamic dispatch.
type ISymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolContext differentiates from other interfaces.
	IsSymbolContext()
}

type SymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolContext() *SymbolContext {
	var p = new(SymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_symbol
	return p
}

func (*SymbolContext) IsSymbolContext() {}

func NewSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolContext {
	var p = new(SymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_symbol

	return p
}

func (s *SymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *SymbolContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *SymbolContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *SymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSymbol(s)
	}
}

func (s *SymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSymbol(s)
	}
}

func (s *SymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Symbol() (localctx ISymbolContext) {
	localctx = NewSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ASNParserRULE_symbol)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserL_BRACE {
		{
			p.SetState(368)
			p.Match(ASNParserL_BRACE)
		}
		{
			p.SetState(369)
			p.Match(ASNParserR_BRACE)
		}

	}

	return localctx
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_assignmentList
	return p
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignment() []IAssignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentContext)(nil)).Elem())
	var tst = make([]IAssignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentContext)
		}
	}

	return tst
}

func (s *AssignmentListContext) Assignment(i int) IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (s *AssignmentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitAssignmentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ASNParserRULE_assignmentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Assignment()
	}

	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserIDENTIFIER {
		{
			p.SetState(373)
			p.Assignment()
		}

		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *AssignmentContext) ValueAssignment() IValueAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueAssignmentContext)
}

func (s *AssignmentContext) TypeAssignment() ITypeAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAssignmentContext)
}

func (s *AssignmentContext) ParameterizedAssignment() IParameterizedAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterizedAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterizedAssignmentContext)
}

func (s *AssignmentContext) ObjectClassAssignment() IObjectClassAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassAssignmentContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (s *AssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ASNParserRULE_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(380)
			p.ValueAssignment()
		}

	case 2:
		{
			p.SetState(381)
			p.TypeAssignment()
		}

	case 3:
		{
			p.SetState(382)
			p.ParameterizedAssignment()
		}

	case 4:
		{
			p.SetState(383)
			p.ObjectClassAssignment()
		}

	}

	return localctx
}

// ISequenceTypeContext is an interface to support dynamic dispatch.
type ISequenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceTypeContext differentiates from other interfaces.
	IsSequenceTypeContext()
}

type SequenceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceTypeContext() *SequenceTypeContext {
	var p = new(SequenceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_sequenceType
	return p
}

func (*SequenceTypeContext) IsSequenceTypeContext() {}

func NewSequenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceTypeContext {
	var p = new(SequenceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_sequenceType

	return p
}

func (s *SequenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceTypeContext) SEQUENCE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSEQUENCE_LITERAL, 0)
}

func (s *SequenceTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *SequenceTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *SequenceTypeContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *SequenceTypeContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *SequenceTypeContext) ComponentTypeLists() IComponentTypeListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListsContext)
}

func (s *SequenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSequenceType(s)
	}
}

func (s *SequenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSequenceType(s)
	}
}

func (s *SequenceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSequenceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SequenceType() (localctx ISequenceTypeContext) {
	localctx = NewSequenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ASNParserRULE_sequenceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.Match(ASNParserSEQUENCE_LITERAL)
	}
	{
		p.SetState(387)
		p.Match(ASNParserL_BRACE)
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(388)
			p.ExtensionAndException()
		}
		{
			p.SetState(389)
			p.OptionalExtensionMarker()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(391)
			p.ComponentTypeLists()
		}

	}
	{
		p.SetState(394)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IExtensionAndExceptionContext is an interface to support dynamic dispatch.
type IExtensionAndExceptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAndExceptionContext differentiates from other interfaces.
	IsExtensionAndExceptionContext()
}

type ExtensionAndExceptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAndExceptionContext() *ExtensionAndExceptionContext {
	var p = new(ExtensionAndExceptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAndException
	return p
}

func (*ExtensionAndExceptionContext) IsExtensionAndExceptionContext() {}

func NewExtensionAndExceptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAndExceptionContext {
	var p = new(ExtensionAndExceptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAndException

	return p
}

func (s *ExtensionAndExceptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAndExceptionContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *ExtensionAndExceptionContext) ExceptionSpec() IExceptionSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecContext)
}

func (s *ExtensionAndExceptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAndExceptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAndExceptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAndException(s)
	}
}

func (s *ExtensionAndExceptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAndException(s)
	}
}

func (s *ExtensionAndExceptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExtensionAndException(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExtensionAndException() (localctx IExtensionAndExceptionContext) {
	localctx = NewExtensionAndExceptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ASNParserRULE_extensionAndException)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.Match(ASNParserELLIPSIS)
	}
	p.SetState(398)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserEXCLAM {
		{
			p.SetState(397)
			p.ExceptionSpec()
		}

	}

	return localctx
}

// IOptionalExtensionMarkerContext is an interface to support dynamic dispatch.
type IOptionalExtensionMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalExtensionMarkerContext differentiates from other interfaces.
	IsOptionalExtensionMarkerContext()
}

type OptionalExtensionMarkerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalExtensionMarkerContext() *OptionalExtensionMarkerContext {
	var p = new(OptionalExtensionMarkerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_optionalExtensionMarker
	return p
}

func (*OptionalExtensionMarkerContext) IsOptionalExtensionMarkerContext() {}

func NewOptionalExtensionMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalExtensionMarkerContext {
	var p = new(OptionalExtensionMarkerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_optionalExtensionMarker

	return p
}

func (s *OptionalExtensionMarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalExtensionMarkerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, 0)
}

func (s *OptionalExtensionMarkerContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *OptionalExtensionMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalExtensionMarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalExtensionMarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterOptionalExtensionMarker(s)
	}
}

func (s *OptionalExtensionMarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitOptionalExtensionMarker(s)
	}
}

func (s *OptionalExtensionMarkerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitOptionalExtensionMarker(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) OptionalExtensionMarker() (localctx IOptionalExtensionMarkerContext) {
	localctx = NewOptionalExtensionMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ASNParserRULE_optionalExtensionMarker)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserCOMMA {
		{
			p.SetState(400)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(401)
			p.Match(ASNParserELLIPSIS)
		}

	}

	return localctx
}

// IComponentTypeListsContext is an interface to support dynamic dispatch.
type IComponentTypeListsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentTypeListsContext differentiates from other interfaces.
	IsComponentTypeListsContext()
}

type ComponentTypeListsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentTypeListsContext() *ComponentTypeListsContext {
	var p = new(ComponentTypeListsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentTypeLists
	return p
}

func (*ComponentTypeListsContext) IsComponentTypeListsContext() {}

func NewComponentTypeListsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentTypeListsContext {
	var p = new(ComponentTypeListsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentTypeLists

	return p
}

func (s *ComponentTypeListsContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentTypeListsContext) AllRootComponentTypeList() []IRootComponentTypeListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRootComponentTypeListContext)(nil)).Elem())
	var tst = make([]IRootComponentTypeListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRootComponentTypeListContext)
		}
	}

	return tst
}

func (s *ComponentTypeListsContext) RootComponentTypeList(i int) IRootComponentTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootComponentTypeListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRootComponentTypeListContext)
}

func (s *ComponentTypeListsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ComponentTypeListsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ComponentTypeListsContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *ComponentTypeListsContext) ExtensionAdditions() IExtensionAdditionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionsContext)
}

func (s *ComponentTypeListsContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *ComponentTypeListsContext) EXTENSTIONENDMARKER() antlr.TerminalNode {
	return s.GetToken(ASNParserEXTENSTIONENDMARKER, 0)
}

func (s *ComponentTypeListsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentTypeListsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentTypeListsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentTypeLists(s)
	}
}

func (s *ComponentTypeListsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentTypeLists(s)
	}
}

func (s *ComponentTypeListsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitComponentTypeLists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ComponentTypeLists() (localctx IComponentTypeListsContext) {
	localctx = NewComponentTypeListsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ASNParserRULE_componentTypeLists)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(424)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserCOMPONENTS_LITERAL, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(404)
			p.RootComponentTypeList()
		}
		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(405)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(406)
				p.ExtensionAndException()
			}
			{
				p.SetState(407)
				p.ExtensionAdditions()
			}
			p.SetState(412)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ASNParserR_BRACE, ASNParserCOMMA:
				{
					p.SetState(408)
					p.OptionalExtensionMarker()
				}

			case ASNParserEXTENSTIONENDMARKER:
				{
					p.SetState(409)
					p.Match(ASNParserEXTENSTIONENDMARKER)
				}
				{
					p.SetState(410)
					p.Match(ASNParserCOMMA)
				}
				{
					p.SetState(411)
					p.RootComponentTypeList()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}

	case ASNParserELLIPSIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(416)
			p.ExtensionAndException()
		}
		{
			p.SetState(417)
			p.ExtensionAdditions()
		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserR_BRACE, ASNParserCOMMA:
			{
				p.SetState(418)
				p.OptionalExtensionMarker()
			}

		case ASNParserEXTENSTIONENDMARKER:
			{
				p.SetState(419)
				p.Match(ASNParserEXTENSTIONENDMARKER)
			}
			{
				p.SetState(420)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(421)
				p.RootComponentTypeList()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRootComponentTypeListContext is an interface to support dynamic dispatch.
type IRootComponentTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootComponentTypeListContext differentiates from other interfaces.
	IsRootComponentTypeListContext()
}

type RootComponentTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootComponentTypeListContext() *RootComponentTypeListContext {
	var p = new(RootComponentTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_rootComponentTypeList
	return p
}

func (*RootComponentTypeListContext) IsRootComponentTypeListContext() {}

func NewRootComponentTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootComponentTypeListContext {
	var p = new(RootComponentTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_rootComponentTypeList

	return p
}

func (s *RootComponentTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *RootComponentTypeListContext) ComponentTypeList() IComponentTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListContext)
}

func (s *RootComponentTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootComponentTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootComponentTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterRootComponentTypeList(s)
	}
}

func (s *RootComponentTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitRootComponentTypeList(s)
	}
}

func (s *RootComponentTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitRootComponentTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) RootComponentTypeList() (localctx IRootComponentTypeListContext) {
	localctx = NewRootComponentTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ASNParserRULE_rootComponentTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(426)
		p.ComponentTypeList()
	}

	return localctx
}

// IComponentTypeListContext is an interface to support dynamic dispatch.
type IComponentTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentTypeListContext differentiates from other interfaces.
	IsComponentTypeListContext()
}

type ComponentTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentTypeListContext() *ComponentTypeListContext {
	var p = new(ComponentTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentTypeList
	return p
}

func (*ComponentTypeListContext) IsComponentTypeListContext() {}

func NewComponentTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentTypeListContext {
	var p = new(ComponentTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentTypeList

	return p
}

func (s *ComponentTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentTypeListContext) AllComponentType() []IComponentTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComponentTypeContext)(nil)).Elem())
	var tst = make([]IComponentTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComponentTypeContext)
		}
	}

	return tst
}

func (s *ComponentTypeListContext) ComponentType(i int) IComponentTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeContext)
}

func (s *ComponentTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ComponentTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ComponentTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentTypeList(s)
	}
}

func (s *ComponentTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentTypeList(s)
	}
}

func (s *ComponentTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitComponentTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ComponentTypeList() (localctx IComponentTypeListContext) {
	localctx = NewComponentTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ASNParserRULE_componentTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(428)
		p.ComponentType()
	}

	p.SetState(433)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(429)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(430)
				p.ComponentType()
			}

		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// IComponentTypeContext is an interface to support dynamic dispatch.
type IComponentTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentTypeContext differentiates from other interfaces.
	IsComponentTypeContext()
}

type ComponentTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentTypeContext() *ComponentTypeContext {
	var p = new(ComponentTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentType
	return p
}

func (*ComponentTypeContext) IsComponentTypeContext() {}

func NewComponentTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentTypeContext {
	var p = new(ComponentTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentType

	return p
}

func (s *ComponentTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentTypeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *ComponentTypeContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *ComponentTypeContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *ComponentTypeContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ComponentTypeContext) COMPONENTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMPONENTS_LITERAL, 0)
}

func (s *ComponentTypeContext) OF_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOF_LITERAL, 0)
}

func (s *ComponentTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ComponentTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentType(s)
	}
}

func (s *ComponentTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentType(s)
	}
}

func (s *ComponentTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitComponentType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ComponentType() (localctx IComponentTypeContext) {
	localctx = NewComponentTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ASNParserRULE_componentType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(445)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(436)
			p.NamedType()
		}
		p.SetState(440)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserOPTIONAL_LITERAL:
			{
				p.SetState(437)
				p.Match(ASNParserOPTIONAL_LITERAL)
			}

		case ASNParserDEFAULT_LITERAL:
			{
				p.SetState(438)
				p.Match(ASNParserDEFAULT_LITERAL)
			}
			{
				p.SetState(439)
				p.Value()
			}

		case ASNParserR_BRACE, ASNParserCOMMA, ASNParserDOUBLE_R_BRACKET, ASNParserEXTENSTIONENDMARKER:

		default:
		}

	case ASNParserCOMPONENTS_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(442)
			p.Match(ASNParserCOMPONENTS_LITERAL)
		}
		{
			p.SetState(443)
			p.Match(ASNParserOF_LITERAL)
		}
		{
			p.SetState(444)
			p.AsnType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtensionAdditionsContext is an interface to support dynamic dispatch.
type IExtensionAdditionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionsContext differentiates from other interfaces.
	IsExtensionAdditionsContext()
}

type ExtensionAdditionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionsContext() *ExtensionAdditionsContext {
	var p = new(ExtensionAdditionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditions
	return p
}

func (*ExtensionAdditionsContext) IsExtensionAdditionsContext() {}

func NewExtensionAdditionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionsContext {
	var p = new(ExtensionAdditionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditions

	return p
}

func (s *ExtensionAdditionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, 0)
}

func (s *ExtensionAdditionsContext) ExtensionAdditionList() IExtensionAdditionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionListContext)
}

func (s *ExtensionAdditionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditions(s)
	}
}

func (s *ExtensionAdditionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditions(s)
	}
}

func (s *ExtensionAdditionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExtensionAdditions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExtensionAdditions() (localctx IExtensionAdditionsContext) {
	localctx = NewExtensionAdditionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ASNParserRULE_extensionAdditions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(449)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(447)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(448)
			p.ExtensionAdditionList()
		}

	}

	return localctx
}

// IExtensionAdditionListContext is an interface to support dynamic dispatch.
type IExtensionAdditionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionListContext differentiates from other interfaces.
	IsExtensionAdditionListContext()
}

type ExtensionAdditionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionListContext() *ExtensionAdditionListContext {
	var p = new(ExtensionAdditionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionList
	return p
}

func (*ExtensionAdditionListContext) IsExtensionAdditionListContext() {}

func NewExtensionAdditionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionListContext {
	var p = new(ExtensionAdditionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionList

	return p
}

func (s *ExtensionAdditionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionListContext) AllExtensionAddition() []IExtensionAdditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExtensionAdditionContext)(nil)).Elem())
	var tst = make([]IExtensionAdditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExtensionAdditionContext)
		}
	}

	return tst
}

func (s *ExtensionAdditionListContext) ExtensionAddition(i int) IExtensionAdditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionContext)
}

func (s *ExtensionAdditionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ExtensionAdditionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ExtensionAdditionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionList(s)
	}
}

func (s *ExtensionAdditionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionList(s)
	}
}

func (s *ExtensionAdditionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExtensionAdditionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExtensionAdditionList() (localctx IExtensionAdditionListContext) {
	localctx = NewExtensionAdditionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ASNParserRULE_extensionAdditionList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.ExtensionAddition()
	}

	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(452)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(453)
				p.ExtensionAddition()
			}

		}
		p.SetState(458)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
	}

	return localctx
}

// IExtensionAdditionContext is an interface to support dynamic dispatch.
type IExtensionAdditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionContext differentiates from other interfaces.
	IsExtensionAdditionContext()
}

type ExtensionAdditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionContext() *ExtensionAdditionContext {
	var p = new(ExtensionAdditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAddition
	return p
}

func (*ExtensionAdditionContext) IsExtensionAdditionContext() {}

func NewExtensionAdditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionContext {
	var p = new(ExtensionAdditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAddition

	return p
}

func (s *ExtensionAdditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionContext) ComponentType() IComponentTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeContext)
}

func (s *ExtensionAdditionContext) ExtensionAdditionGroup() IExtensionAdditionGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionGroupContext)
}

func (s *ExtensionAdditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAddition(s)
	}
}

func (s *ExtensionAdditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAddition(s)
	}
}

func (s *ExtensionAdditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExtensionAddition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExtensionAddition() (localctx IExtensionAdditionContext) {
	localctx = NewExtensionAdditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ASNParserRULE_extensionAddition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(461)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserCOMPONENTS_LITERAL, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(459)
			p.ComponentType()
		}

	case ASNParserDOUBLE_L_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(460)
			p.ExtensionAdditionGroup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtensionAdditionGroupContext is an interface to support dynamic dispatch.
type IExtensionAdditionGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionGroupContext differentiates from other interfaces.
	IsExtensionAdditionGroupContext()
}

type ExtensionAdditionGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionGroupContext() *ExtensionAdditionGroupContext {
	var p = new(ExtensionAdditionGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionGroup
	return p
}

func (*ExtensionAdditionGroupContext) IsExtensionAdditionGroupContext() {}

func NewExtensionAdditionGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionGroupContext {
	var p = new(ExtensionAdditionGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionGroup

	return p
}

func (s *ExtensionAdditionGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionGroupContext) DOUBLE_L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserDOUBLE_L_BRACKET, 0)
}

func (s *ExtensionAdditionGroupContext) VersionNumber() IVersionNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVersionNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVersionNumberContext)
}

func (s *ExtensionAdditionGroupContext) ComponentTypeList() IComponentTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListContext)
}

func (s *ExtensionAdditionGroupContext) DOUBLE_R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserDOUBLE_R_BRACKET, 0)
}

func (s *ExtensionAdditionGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionGroup(s)
	}
}

func (s *ExtensionAdditionGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionGroup(s)
	}
}

func (s *ExtensionAdditionGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExtensionAdditionGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExtensionAdditionGroup() (localctx IExtensionAdditionGroupContext) {
	localctx = NewExtensionAdditionGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ASNParserRULE_extensionAdditionGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(463)
		p.Match(ASNParserDOUBLE_L_BRACKET)
	}
	{
		p.SetState(464)
		p.VersionNumber()
	}
	{
		p.SetState(465)
		p.ComponentTypeList()
	}
	{
		p.SetState(466)
		p.Match(ASNParserDOUBLE_R_BRACKET)
	}

	return localctx
}

// IVersionNumberContext is an interface to support dynamic dispatch.
type IVersionNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVersionNumberContext differentiates from other interfaces.
	IsVersionNumberContext()
}

type VersionNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionNumberContext() *VersionNumberContext {
	var p = new(VersionNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_versionNumber
	return p
}

func (*VersionNumberContext) IsVersionNumberContext() {}

func NewVersionNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionNumberContext {
	var p = new(VersionNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_versionNumber

	return p
}

func (s *VersionNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASNParserNUMBER, 0)
}

func (s *VersionNumberContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserCOLON, 0)
}

func (s *VersionNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterVersionNumber(s)
	}
}

func (s *VersionNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitVersionNumber(s)
	}
}

func (s *VersionNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitVersionNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) VersionNumber() (localctx IVersionNumberContext) {
	localctx = NewVersionNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ASNParserRULE_versionNumber)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserNUMBER {
		{
			p.SetState(468)
			p.Match(ASNParserNUMBER)
		}
		{
			p.SetState(469)
			p.Match(ASNParserCOLON)
		}

	}

	return localctx
}

// ISequenceOfTypeContext is an interface to support dynamic dispatch.
type ISequenceOfTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceOfTypeContext differentiates from other interfaces.
	IsSequenceOfTypeContext()
}

type SequenceOfTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceOfTypeContext() *SequenceOfTypeContext {
	var p = new(SequenceOfTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_sequenceOfType
	return p
}

func (*SequenceOfTypeContext) IsSequenceOfTypeContext() {}

func NewSequenceOfTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceOfTypeContext {
	var p = new(SequenceOfTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_sequenceOfType

	return p
}

func (s *SequenceOfTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceOfTypeContext) SEQUENCE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSEQUENCE_LITERAL, 0)
}

func (s *SequenceOfTypeContext) OF_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOF_LITERAL, 0)
}

func (s *SequenceOfTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *SequenceOfTypeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *SequenceOfTypeContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, 0)
}

func (s *SequenceOfTypeContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, 0)
}

func (s *SequenceOfTypeContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *SequenceOfTypeContext) SizeConstraint() ISizeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISizeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISizeConstraintContext)
}

func (s *SequenceOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceOfTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSequenceOfType(s)
	}
}

func (s *SequenceOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSequenceOfType(s)
	}
}

func (s *SequenceOfTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSequenceOfType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SequenceOfType() (localctx ISequenceOfTypeContext) {
	localctx = NewSequenceOfTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ASNParserRULE_sequenceOfType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(472)
		p.Match(ASNParserSEQUENCE_LITERAL)
	}
	p.SetState(480)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserL_PARAN {
		{
			p.SetState(473)
			p.Match(ASNParserL_PARAN)
		}
		p.SetState(476)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserL_PARAN:
			{
				p.SetState(474)
				p.Constraint()
			}

		case ASNParserSIZE_LITERAL:
			{
				p.SetState(475)
				p.SizeConstraint()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(478)
			p.Match(ASNParserR_PARAN)
		}

	}
	{
		p.SetState(482)
		p.Match(ASNParserOF_LITERAL)
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(483)
			p.AsnType()
		}

	case 2:
		{
			p.SetState(484)
			p.NamedType()
		}

	}

	return localctx
}

// ISizeConstraintContext is an interface to support dynamic dispatch.
type ISizeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSizeConstraintContext differentiates from other interfaces.
	IsSizeConstraintContext()
}

type SizeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySizeConstraintContext() *SizeConstraintContext {
	var p = new(SizeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_sizeConstraint
	return p
}

func (*SizeConstraintContext) IsSizeConstraintContext() {}

func NewSizeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SizeConstraintContext {
	var p = new(SizeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_sizeConstraint

	return p
}

func (s *SizeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SizeConstraintContext) SIZE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSIZE_LITERAL, 0)
}

func (s *SizeConstraintContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *SizeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SizeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SizeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSizeConstraint(s)
	}
}

func (s *SizeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSizeConstraint(s)
	}
}

func (s *SizeConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSizeConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SizeConstraint() (localctx ISizeConstraintContext) {
	localctx = NewSizeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ASNParserRULE_sizeConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(ASNParserSIZE_LITERAL)
	}
	{
		p.SetState(488)
		p.Constraint()
	}

	return localctx
}

// IParameterizedAssignmentContext is an interface to support dynamic dispatch.
type IParameterizedAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterizedAssignmentContext differentiates from other interfaces.
	IsParameterizedAssignmentContext()
}

type ParameterizedAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterizedAssignmentContext() *ParameterizedAssignmentContext {
	var p = new(ParameterizedAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_parameterizedAssignment
	return p
}

func (*ParameterizedAssignmentContext) IsParameterizedAssignmentContext() {}

func NewParameterizedAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterizedAssignmentContext {
	var p = new(ParameterizedAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_parameterizedAssignment

	return p
}

func (s *ParameterizedAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterizedAssignmentContext) ParameterList() IParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ParameterizedAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASNParserASSIGN_OP, 0)
}

func (s *ParameterizedAssignmentContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ParameterizedAssignmentContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ParameterizedAssignmentContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *ParameterizedAssignmentContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ParameterizedAssignmentContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *ParameterizedAssignmentContext) ObjectClass() IObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassContext)
}

func (s *ParameterizedAssignmentContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *ParameterizedAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterizedAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterizedAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParameterizedAssignment(s)
	}
}

func (s *ParameterizedAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParameterizedAssignment(s)
	}
}

func (s *ParameterizedAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitParameterizedAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ParameterizedAssignment() (localctx IParameterizedAssignmentContext) {
	localctx = NewParameterizedAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ASNParserRULE_parameterizedAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(504)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserL_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(490)
			p.ParameterList()
		}

		{
			p.SetState(491)
			p.Match(ASNParserASSIGN_OP)
		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(492)
				p.AsnType()
			}

		case 2:
			{
				p.SetState(493)
				p.Value()
			}

		case 3:
			{
				p.SetState(494)
				p.ValueSet()
			}

		}

	case ASNParserTYPE_IDENTIFIER_LITERAL, ASNParserABSTRACT_SYNTAX_LITERAL, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(497)
			p.DefinedObjectClass()
		}
		{
			p.SetState(498)
			p.Match(ASNParserASSIGN_OP)
		}
		p.SetState(502)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(499)
				p.Object()
			}

		case 2:
			{
				p.SetState(500)
				p.ObjectClass()
			}

		case 3:
			{
				p.SetState(501)
				p.ObjectSet()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_parameterList
	return p
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ParameterListContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *ParameterListContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterListContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (s *ParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ASNParserRULE_parameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(506)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(507)
		p.Parameter()
	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(508)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(509)
			p.Parameter()
		}

		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(515)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ParameterContext) ParamGovernor() IParamGovernorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamGovernorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamGovernorContext)
}

func (s *ParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserCOLON, 0)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ASNParserRULE_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(520)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(517)
			p.ParamGovernor()
		}
		{
			p.SetState(518)
			p.Match(ASNParserCOLON)
		}

	}
	{
		p.SetState(522)
		p.Match(ASNParserIDENTIFIER)
	}

	return localctx
}

// IParamGovernorContext is an interface to support dynamic dispatch.
type IParamGovernorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamGovernorContext differentiates from other interfaces.
	IsParamGovernorContext()
}

type ParamGovernorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamGovernorContext() *ParamGovernorContext {
	var p = new(ParamGovernorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_paramGovernor
	return p
}

func (*ParamGovernorContext) IsParamGovernorContext() {}

func NewParamGovernorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamGovernorContext {
	var p = new(ParamGovernorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_paramGovernor

	return p
}

func (s *ParamGovernorContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamGovernorContext) Governor() IGovernorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGovernorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGovernorContext)
}

func (s *ParamGovernorContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ParamGovernorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamGovernorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamGovernorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParamGovernor(s)
	}
}

func (s *ParamGovernorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParamGovernor(s)
	}
}

func (s *ParamGovernorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitParamGovernor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ParamGovernor() (localctx IParamGovernorContext) {
	localctx = NewParamGovernorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ASNParserRULE_paramGovernor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(524)
			p.Governor()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(525)
			p.Match(ASNParserIDENTIFIER)
		}

	}

	return localctx
}

// IGovernorContext is an interface to support dynamic dispatch.
type IGovernorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGovernorContext differentiates from other interfaces.
	IsGovernorContext()
}

type GovernorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGovernorContext() *GovernorContext {
	var p = new(GovernorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_governor
	return p
}

func (*GovernorContext) IsGovernorContext() {}

func NewGovernorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GovernorContext {
	var p = new(GovernorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_governor

	return p
}

func (s *GovernorContext) GetParser() antlr.Parser { return s.parser }

func (s *GovernorContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *GovernorContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *GovernorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GovernorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GovernorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterGovernor(s)
	}
}

func (s *GovernorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitGovernor(s)
	}
}

func (s *GovernorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitGovernor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Governor() (localctx IGovernorContext) {
	localctx = NewGovernorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ASNParserRULE_governor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(528)
			p.AsnType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(529)
			p.DefinedObjectClass()
		}

	}

	return localctx
}

// IObjectClassAssignmentContext is an interface to support dynamic dispatch.
type IObjectClassAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassAssignmentContext differentiates from other interfaces.
	IsObjectClassAssignmentContext()
}

type ObjectClassAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassAssignmentContext() *ObjectClassAssignmentContext {
	var p = new(ObjectClassAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectClassAssignment
	return p
}

func (*ObjectClassAssignmentContext) IsObjectClassAssignmentContext() {}

func NewObjectClassAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassAssignmentContext {
	var p = new(ObjectClassAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectClassAssignment

	return p
}

func (s *ObjectClassAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASNParserASSIGN_OP, 0)
}

func (s *ObjectClassAssignmentContext) ObjectClass() IObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassContext)
}

func (s *ObjectClassAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectClassAssignment(s)
	}
}

func (s *ObjectClassAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectClassAssignment(s)
	}
}

func (s *ObjectClassAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectClassAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectClassAssignment() (localctx IObjectClassAssignmentContext) {
	localctx = NewObjectClassAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ASNParserRULE_objectClassAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(532)
		p.Match(ASNParserASSIGN_OP)
	}
	{
		p.SetState(533)
		p.ObjectClass()
	}

	return localctx
}

// IObjectClassContext is an interface to support dynamic dispatch.
type IObjectClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassContext differentiates from other interfaces.
	IsObjectClassContext()
}

type ObjectClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassContext() *ObjectClassContext {
	var p = new(ObjectClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectClass
	return p
}

func (*ObjectClassContext) IsObjectClassContext() {}

func NewObjectClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassContext {
	var p = new(ObjectClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectClass

	return p
}

func (s *ObjectClassContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectClassContext) ObjectClassDefn() IObjectClassDefnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassDefnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassDefnContext)
}

func (s *ObjectClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectClass(s)
	}
}

func (s *ObjectClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectClass(s)
	}
}

func (s *ObjectClassContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectClass(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectClass() (localctx IObjectClassContext) {
	localctx = NewObjectClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ASNParserRULE_objectClass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(537)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserTYPE_IDENTIFIER_LITERAL, ASNParserABSTRACT_SYNTAX_LITERAL, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(535)
			p.DefinedObjectClass()
		}

	case ASNParserCLASS_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(536)
			p.ObjectClassDefn()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDefinedObjectClassContext is an interface to support dynamic dispatch.
type IDefinedObjectClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedObjectClassContext differentiates from other interfaces.
	IsDefinedObjectClassContext()
}

type DefinedObjectClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedObjectClassContext() *DefinedObjectClassContext {
	var p = new(DefinedObjectClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_definedObjectClass
	return p
}

func (*DefinedObjectClassContext) IsDefinedObjectClassContext() {}

func NewDefinedObjectClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedObjectClassContext {
	var p = new(DefinedObjectClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_definedObjectClass

	return p
}

func (s *DefinedObjectClassContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedObjectClassContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *DefinedObjectClassContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *DefinedObjectClassContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *DefinedObjectClassContext) TYPE_IDENTIFIER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserTYPE_IDENTIFIER_LITERAL, 0)
}

func (s *DefinedObjectClassContext) ABSTRACT_SYNTAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserABSTRACT_SYNTAX_LITERAL, 0)
}

func (s *DefinedObjectClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedObjectClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedObjectClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterDefinedObjectClass(s)
	}
}

func (s *DefinedObjectClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitDefinedObjectClass(s)
	}
}

func (s *DefinedObjectClassContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitDefinedObjectClass(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) DefinedObjectClass() (localctx IDefinedObjectClassContext) {
	localctx = NewDefinedObjectClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ASNParserRULE_definedObjectClass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(546)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(541)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(539)
				p.Match(ASNParserIDENTIFIER)
			}
			{
				p.SetState(540)
				p.Match(ASNParserDOT)
			}

		}
		{
			p.SetState(543)
			p.Match(ASNParserIDENTIFIER)
		}

	case ASNParserTYPE_IDENTIFIER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(544)
			p.Match(ASNParserTYPE_IDENTIFIER_LITERAL)
		}

	case ASNParserABSTRACT_SYNTAX_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(545)
			p.Match(ASNParserABSTRACT_SYNTAX_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUsefulObjectClassReferenceContext is an interface to support dynamic dispatch.
type IUsefulObjectClassReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsefulObjectClassReferenceContext differentiates from other interfaces.
	IsUsefulObjectClassReferenceContext()
}

type UsefulObjectClassReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsefulObjectClassReferenceContext() *UsefulObjectClassReferenceContext {
	var p = new(UsefulObjectClassReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_usefulObjectClassReference
	return p
}

func (*UsefulObjectClassReferenceContext) IsUsefulObjectClassReferenceContext() {}

func NewUsefulObjectClassReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsefulObjectClassReferenceContext {
	var p = new(UsefulObjectClassReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_usefulObjectClassReference

	return p
}

func (s *UsefulObjectClassReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *UsefulObjectClassReferenceContext) TYPE_IDENTIFIER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserTYPE_IDENTIFIER_LITERAL, 0)
}

func (s *UsefulObjectClassReferenceContext) ABSTRACT_SYNTAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserABSTRACT_SYNTAX_LITERAL, 0)
}

func (s *UsefulObjectClassReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsefulObjectClassReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsefulObjectClassReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterUsefulObjectClassReference(s)
	}
}

func (s *UsefulObjectClassReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitUsefulObjectClassReference(s)
	}
}

func (s *UsefulObjectClassReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitUsefulObjectClassReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) UsefulObjectClassReference() (localctx IUsefulObjectClassReferenceContext) {
	localctx = NewUsefulObjectClassReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ASNParserRULE_usefulObjectClassReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASNParserTYPE_IDENTIFIER_LITERAL || _la == ASNParserABSTRACT_SYNTAX_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExternalObjectClassReferenceContext is an interface to support dynamic dispatch.
type IExternalObjectClassReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalObjectClassReferenceContext differentiates from other interfaces.
	IsExternalObjectClassReferenceContext()
}

type ExternalObjectClassReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalObjectClassReferenceContext() *ExternalObjectClassReferenceContext {
	var p = new(ExternalObjectClassReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_externalObjectClassReference
	return p
}

func (*ExternalObjectClassReferenceContext) IsExternalObjectClassReferenceContext() {}

func NewExternalObjectClassReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalObjectClassReferenceContext {
	var p = new(ExternalObjectClassReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_externalObjectClassReference

	return p
}

func (s *ExternalObjectClassReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalObjectClassReferenceContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *ExternalObjectClassReferenceContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *ExternalObjectClassReferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *ExternalObjectClassReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalObjectClassReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalObjectClassReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExternalObjectClassReference(s)
	}
}

func (s *ExternalObjectClassReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExternalObjectClassReference(s)
	}
}

func (s *ExternalObjectClassReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExternalObjectClassReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExternalObjectClassReference() (localctx IExternalObjectClassReferenceContext) {
	localctx = NewExternalObjectClassReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ASNParserRULE_externalObjectClassReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(550)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(551)
		p.Match(ASNParserDOT)
	}
	{
		p.SetState(552)
		p.Match(ASNParserIDENTIFIER)
	}

	return localctx
}

// IObjectClassDefnContext is an interface to support dynamic dispatch.
type IObjectClassDefnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassDefnContext differentiates from other interfaces.
	IsObjectClassDefnContext()
}

type ObjectClassDefnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassDefnContext() *ObjectClassDefnContext {
	var p = new(ObjectClassDefnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectClassDefn
	return p
}

func (*ObjectClassDefnContext) IsObjectClassDefnContext() {}

func NewObjectClassDefnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassDefnContext {
	var p = new(ObjectClassDefnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectClassDefn

	return p
}

func (s *ObjectClassDefnContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassDefnContext) CLASS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCLASS_LITERAL, 0)
}

func (s *ObjectClassDefnContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ObjectClassDefnContext) AllFieldSpec() []IFieldSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldSpecContext)(nil)).Elem())
	var tst = make([]IFieldSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldSpecContext)
		}
	}

	return tst
}

func (s *ObjectClassDefnContext) FieldSpec(i int) IFieldSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldSpecContext)
}

func (s *ObjectClassDefnContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ObjectClassDefnContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ObjectClassDefnContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ObjectClassDefnContext) WithSyntaxSpec() IWithSyntaxSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithSyntaxSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithSyntaxSpecContext)
}

func (s *ObjectClassDefnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassDefnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassDefnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectClassDefn(s)
	}
}

func (s *ObjectClassDefnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectClassDefn(s)
	}
}

func (s *ObjectClassDefnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectClassDefn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectClassDefn() (localctx IObjectClassDefnContext) {
	localctx = NewObjectClassDefnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ASNParserRULE_objectClassDefn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(554)
		p.Match(ASNParserCLASS_LITERAL)
	}
	{
		p.SetState(555)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(556)
		p.FieldSpec()
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(557)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(558)
			p.FieldSpec()
		}

		p.SetState(563)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(564)
		p.Match(ASNParserR_BRACE)
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserWITH_LITERAL {
		{
			p.SetState(565)
			p.WithSyntaxSpec()
		}

	}

	return localctx
}

// IWithSyntaxSpecContext is an interface to support dynamic dispatch.
type IWithSyntaxSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithSyntaxSpecContext differentiates from other interfaces.
	IsWithSyntaxSpecContext()
}

type WithSyntaxSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithSyntaxSpecContext() *WithSyntaxSpecContext {
	var p = new(WithSyntaxSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_withSyntaxSpec
	return p
}

func (*WithSyntaxSpecContext) IsWithSyntaxSpecContext() {}

func NewWithSyntaxSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithSyntaxSpecContext {
	var p = new(WithSyntaxSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_withSyntaxSpec

	return p
}

func (s *WithSyntaxSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WithSyntaxSpecContext) WITH_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserWITH_LITERAL, 0)
}

func (s *WithSyntaxSpecContext) SYNTAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSYNTAX_LITERAL, 0)
}

func (s *WithSyntaxSpecContext) SyntaxList() ISyntaxListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISyntaxListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISyntaxListContext)
}

func (s *WithSyntaxSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithSyntaxSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithSyntaxSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterWithSyntaxSpec(s)
	}
}

func (s *WithSyntaxSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitWithSyntaxSpec(s)
	}
}

func (s *WithSyntaxSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitWithSyntaxSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) WithSyntaxSpec() (localctx IWithSyntaxSpecContext) {
	localctx = NewWithSyntaxSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ASNParserRULE_withSyntaxSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(568)
		p.Match(ASNParserWITH_LITERAL)
	}
	{
		p.SetState(569)
		p.Match(ASNParserSYNTAX_LITERAL)
	}
	{
		p.SetState(570)
		p.SyntaxList()
	}

	return localctx
}

// ISyntaxListContext is an interface to support dynamic dispatch.
type ISyntaxListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSyntaxListContext differentiates from other interfaces.
	IsSyntaxListContext()
}

type SyntaxListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxListContext() *SyntaxListContext {
	var p = new(SyntaxListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_syntaxList
	return p
}

func (*SyntaxListContext) IsSyntaxListContext() {}

func NewSyntaxListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxListContext {
	var p = new(SyntaxListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_syntaxList

	return p
}

func (s *SyntaxListContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxListContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *SyntaxListContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *SyntaxListContext) AllTokenOrGroupSpec() []ITokenOrGroupSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem())
	var tst = make([]ITokenOrGroupSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokenOrGroupSpecContext)
		}
	}

	return tst
}

func (s *SyntaxListContext) TokenOrGroupSpec(i int) ITokenOrGroupSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokenOrGroupSpecContext)
}

func (s *SyntaxListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSyntaxList(s)
	}
}

func (s *SyntaxListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSyntaxList(s)
	}
}

func (s *SyntaxListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSyntaxList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SyntaxList() (localctx ISyntaxListContext) {
	localctx = NewSyntaxListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ASNParserRULE_syntaxList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Match(ASNParserL_BRACE)
	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASNParserAMPERSAND || _la == ASNParserCOMMA || _la == ASNParserL_BRACKET || _la == ASNParserIDENTIFIER {
		{
			p.SetState(573)
			p.TokenOrGroupSpec()
		}

		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(578)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// ITokenOrGroupSpecContext is an interface to support dynamic dispatch.
type ITokenOrGroupSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokenOrGroupSpecContext differentiates from other interfaces.
	IsTokenOrGroupSpecContext()
}

type TokenOrGroupSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokenOrGroupSpecContext() *TokenOrGroupSpecContext {
	var p = new(TokenOrGroupSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_tokenOrGroupSpec
	return p
}

func (*TokenOrGroupSpecContext) IsTokenOrGroupSpecContext() {}

func NewTokenOrGroupSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokenOrGroupSpecContext {
	var p = new(TokenOrGroupSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_tokenOrGroupSpec

	return p
}

func (s *TokenOrGroupSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TokenOrGroupSpecContext) RequiredToken() IRequiredTokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRequiredTokenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRequiredTokenContext)
}

func (s *TokenOrGroupSpecContext) OptionalGroup() IOptionalGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalGroupContext)
}

func (s *TokenOrGroupSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokenOrGroupSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokenOrGroupSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTokenOrGroupSpec(s)
	}
}

func (s *TokenOrGroupSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTokenOrGroupSpec(s)
	}
}

func (s *TokenOrGroupSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitTokenOrGroupSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) TokenOrGroupSpec() (localctx ITokenOrGroupSpecContext) {
	localctx = NewTokenOrGroupSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ASNParserRULE_tokenOrGroupSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(582)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserAMPERSAND, ASNParserCOMMA, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(580)
			p.RequiredToken()
		}

	case ASNParserL_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(581)
			p.OptionalGroup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOptionalGroupContext is an interface to support dynamic dispatch.
type IOptionalGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalGroupContext differentiates from other interfaces.
	IsOptionalGroupContext()
}

type OptionalGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalGroupContext() *OptionalGroupContext {
	var p = new(OptionalGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_optionalGroup
	return p
}

func (*OptionalGroupContext) IsOptionalGroupContext() {}

func NewOptionalGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalGroupContext {
	var p = new(OptionalGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_optionalGroup

	return p
}

func (s *OptionalGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalGroupContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACKET, 0)
}

func (s *OptionalGroupContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACKET, 0)
}

func (s *OptionalGroupContext) AllTokenOrGroupSpec() []ITokenOrGroupSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem())
	var tst = make([]ITokenOrGroupSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokenOrGroupSpecContext)
		}
	}

	return tst
}

func (s *OptionalGroupContext) TokenOrGroupSpec(i int) ITokenOrGroupSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokenOrGroupSpecContext)
}

func (s *OptionalGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterOptionalGroup(s)
	}
}

func (s *OptionalGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitOptionalGroup(s)
	}
}

func (s *OptionalGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitOptionalGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) OptionalGroup() (localctx IOptionalGroupContext) {
	localctx = NewOptionalGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ASNParserRULE_optionalGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Match(ASNParserL_BRACKET)
	}
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASNParserAMPERSAND || _la == ASNParserCOMMA || _la == ASNParserL_BRACKET || _la == ASNParserIDENTIFIER {
		{
			p.SetState(585)
			p.TokenOrGroupSpec()
		}

		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(590)
		p.Match(ASNParserR_BRACKET)
	}

	return localctx
}

// IRequiredTokenContext is an interface to support dynamic dispatch.
type IRequiredTokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRequiredTokenContext differentiates from other interfaces.
	IsRequiredTokenContext()
}

type RequiredTokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiredTokenContext() *RequiredTokenContext {
	var p = new(RequiredTokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_requiredToken
	return p
}

func (*RequiredTokenContext) IsRequiredTokenContext() {}

func NewRequiredTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiredTokenContext {
	var p = new(RequiredTokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_requiredToken

	return p
}

func (s *RequiredTokenContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiredTokenContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *RequiredTokenContext) PrimitiveFieldName() IPrimitiveFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveFieldNameContext)
}

func (s *RequiredTokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiredTokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiredTokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterRequiredToken(s)
	}
}

func (s *RequiredTokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitRequiredToken(s)
	}
}

func (s *RequiredTokenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitRequiredToken(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) RequiredToken() (localctx IRequiredTokenContext) {
	localctx = NewRequiredTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ASNParserRULE_requiredToken)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(594)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserCOMMA, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(592)
			p.Literal()
		}

	case ASNParserAMPERSAND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(593)
			p.PrimitiveFieldName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *LiteralContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ASNParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASNParserCOMMA || _la == ASNParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrimitiveFieldNameContext is an interface to support dynamic dispatch.
type IPrimitiveFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveFieldNameContext differentiates from other interfaces.
	IsPrimitiveFieldNameContext()
}

type PrimitiveFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveFieldNameContext() *PrimitiveFieldNameContext {
	var p = new(PrimitiveFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_primitiveFieldName
	return p
}

func (*PrimitiveFieldNameContext) IsPrimitiveFieldNameContext() {}

func NewPrimitiveFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveFieldNameContext {
	var p = new(PrimitiveFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_primitiveFieldName

	return p
}

func (s *PrimitiveFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveFieldNameContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *PrimitiveFieldNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *PrimitiveFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterPrimitiveFieldName(s)
	}
}

func (s *PrimitiveFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitPrimitiveFieldName(s)
	}
}

func (s *PrimitiveFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitPrimitiveFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) PrimitiveFieldName() (localctx IPrimitiveFieldNameContext) {
	localctx = NewPrimitiveFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ASNParserRULE_primitiveFieldName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(599)
		p.Match(ASNParserIDENTIFIER)
	}

	return localctx
}

// IFieldSpecContext is an interface to support dynamic dispatch.
type IFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldSpecContext differentiates from other interfaces.
	IsFieldSpecContext()
}

type FieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldSpecContext() *FieldSpecContext {
	var p = new(FieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_fieldSpec
	return p
}

func (*FieldSpecContext) IsFieldSpecContext() {}

func NewFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldSpecContext {
	var p = new(FieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_fieldSpec

	return p
}

func (s *FieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *FieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *FieldSpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *FieldSpecContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldSpecContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *FieldSpecContext) TypeOptionalitySpec() ITypeOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeOptionalitySpecContext)
}

func (s *FieldSpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *FieldSpecContext) ValueSetOptionalitySpec() IValueSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetOptionalitySpecContext)
}

func (s *FieldSpecContext) UNIQUE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserUNIQUE_LITERAL, 0)
}

func (s *FieldSpecContext) ValueOptionalitySpec() IValueOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOptionalitySpecContext)
}

func (s *FieldSpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *FieldSpecContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *FieldSpecContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *FieldSpecContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *FieldSpecContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *FieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterFieldSpec(s)
	}
}

func (s *FieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitFieldSpec(s)
	}
}

func (s *FieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) FieldSpec() (localctx IFieldSpecContext) {
	localctx = NewFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ASNParserRULE_fieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(601)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(602)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.SetState(604)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
			{
				p.SetState(603)
				p.TypeOptionalitySpec()
			}

		}

	case 2:
		{
			p.SetState(606)
			p.AsnType()
		}
		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
		case 1:
			p.SetState(608)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
				{
					p.SetState(607)
					p.ValueSetOptionalitySpec()
				}

			}

		case 2:
			p.SetState(611)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASNParserUNIQUE_LITERAL {
				{
					p.SetState(610)
					p.Match(ASNParserUNIQUE_LITERAL)
				}

			}
			p.SetState(614)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
				{
					p.SetState(613)
					p.ValueOptionalitySpec()
				}

			}

		}

	case 3:
		{
			p.SetState(618)
			p.FieldName()
		}
		p.SetState(625)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserOPTIONAL_LITERAL:
			{
				p.SetState(619)
				p.Match(ASNParserOPTIONAL_LITERAL)
			}

		case ASNParserDEFAULT_LITERAL:
			{
				p.SetState(620)
				p.Match(ASNParserDEFAULT_LITERAL)
			}
			p.SetState(623)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(621)
					p.ValueSet()
				}

			case 2:
				{
					p.SetState(622)
					p.Value()
				}

			}

		case ASNParserR_BRACE, ASNParserCOMMA:

		default:
		}

	case 4:
		{
			p.SetState(627)
			p.DefinedObjectClass()
		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserOPTIONAL_LITERAL:
			{
				p.SetState(628)
				p.Match(ASNParserOPTIONAL_LITERAL)
			}

		case ASNParserDEFAULT_LITERAL:
			{
				p.SetState(629)
				p.Match(ASNParserDEFAULT_LITERAL)
			}
			p.SetState(632)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ASNParserL_BRACE:
				{
					p.SetState(630)
					p.ObjectSet()
				}

			case ASNParserIDENTIFIER:
				{
					p.SetState(631)
					p.Object()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case ASNParserR_BRACE, ASNParserCOMMA:

		default:
		}

	}

	return localctx
}

// ITypeFieldSpecContext is an interface to support dynamic dispatch.
type ITypeFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeFieldSpecContext differentiates from other interfaces.
	IsTypeFieldSpecContext()
}

type TypeFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeFieldSpecContext() *TypeFieldSpecContext {
	var p = new(TypeFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_typeFieldSpec
	return p
}

func (*TypeFieldSpecContext) IsTypeFieldSpecContext() {}

func NewTypeFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeFieldSpecContext {
	var p = new(TypeFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_typeFieldSpec

	return p
}

func (s *TypeFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *TypeFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *TypeFieldSpecContext) TypeOptionalitySpec() ITypeOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeOptionalitySpecContext)
}

func (s *TypeFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTypeFieldSpec(s)
	}
}

func (s *TypeFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTypeFieldSpec(s)
	}
}

func (s *TypeFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitTypeFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) TypeFieldSpec() (localctx ITypeFieldSpecContext) {
	localctx = NewTypeFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ASNParserRULE_typeFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(638)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(639)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(641)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(640)
			p.TypeOptionalitySpec()
		}

	}

	return localctx
}

// ITypeOptionalitySpecContext is an interface to support dynamic dispatch.
type ITypeOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeOptionalitySpecContext differentiates from other interfaces.
	IsTypeOptionalitySpecContext()
}

type TypeOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeOptionalitySpecContext() *TypeOptionalitySpecContext {
	var p = new(TypeOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_typeOptionalitySpec
	return p
}

func (*TypeOptionalitySpecContext) IsTypeOptionalitySpecContext() {}

func NewTypeOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeOptionalitySpecContext {
	var p = new(TypeOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_typeOptionalitySpec

	return p
}

func (s *TypeOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *TypeOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *TypeOptionalitySpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *TypeOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTypeOptionalitySpec(s)
	}
}

func (s *TypeOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTypeOptionalitySpec(s)
	}
}

func (s *TypeOptionalitySpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitTypeOptionalitySpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) TypeOptionalitySpec() (localctx ITypeOptionalitySpecContext) {
	localctx = NewTypeOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ASNParserRULE_typeOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(646)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(643)
			p.Match(ASNParserOPTIONAL_LITERAL)
		}

	case ASNParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(644)
			p.Match(ASNParserDEFAULT_LITERAL)
		}
		{
			p.SetState(645)
			p.AsnType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFixedTypeValueFieldSpecContext is an interface to support dynamic dispatch.
type IFixedTypeValueFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixedTypeValueFieldSpecContext differentiates from other interfaces.
	IsFixedTypeValueFieldSpecContext()
}

type FixedTypeValueFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixedTypeValueFieldSpecContext() *FixedTypeValueFieldSpecContext {
	var p = new(FixedTypeValueFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_fixedTypeValueFieldSpec
	return p
}

func (*FixedTypeValueFieldSpecContext) IsFixedTypeValueFieldSpecContext() {}

func NewFixedTypeValueFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedTypeValueFieldSpecContext {
	var p = new(FixedTypeValueFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_fixedTypeValueFieldSpec

	return p
}

func (s *FixedTypeValueFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedTypeValueFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *FixedTypeValueFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *FixedTypeValueFieldSpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *FixedTypeValueFieldSpecContext) UNIQUE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserUNIQUE_LITERAL, 0)
}

func (s *FixedTypeValueFieldSpecContext) ValueOptionalitySpec() IValueOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOptionalitySpecContext)
}

func (s *FixedTypeValueFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedTypeValueFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedTypeValueFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterFixedTypeValueFieldSpec(s)
	}
}

func (s *FixedTypeValueFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitFixedTypeValueFieldSpec(s)
	}
}

func (s *FixedTypeValueFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitFixedTypeValueFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) FixedTypeValueFieldSpec() (localctx IFixedTypeValueFieldSpecContext) {
	localctx = NewFixedTypeValueFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ASNParserRULE_fixedTypeValueFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(649)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(650)
		p.AsnType()
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserUNIQUE_LITERAL {
		{
			p.SetState(651)
			p.Match(ASNParserUNIQUE_LITERAL)
		}

	}
	p.SetState(655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(654)
			p.ValueOptionalitySpec()
		}

	}

	return localctx
}

// IValueOptionalitySpecContext is an interface to support dynamic dispatch.
type IValueOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueOptionalitySpecContext differentiates from other interfaces.
	IsValueOptionalitySpecContext()
}

type ValueOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueOptionalitySpecContext() *ValueOptionalitySpecContext {
	var p = new(ValueOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_valueOptionalitySpec
	return p
}

func (*ValueOptionalitySpecContext) IsValueOptionalitySpecContext() {}

func NewValueOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueOptionalitySpecContext {
	var p = new(ValueOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_valueOptionalitySpec

	return p
}

func (s *ValueOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *ValueOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *ValueOptionalitySpecContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ValueOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterValueOptionalitySpec(s)
	}
}

func (s *ValueOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitValueOptionalitySpec(s)
	}
}

func (s *ValueOptionalitySpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitValueOptionalitySpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ValueOptionalitySpec() (localctx IValueOptionalitySpecContext) {
	localctx = NewValueOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ASNParserRULE_valueOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(660)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(657)
			p.Match(ASNParserOPTIONAL_LITERAL)
		}

	case ASNParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(658)
			p.Match(ASNParserDEFAULT_LITERAL)
		}
		{
			p.SetState(659)
			p.Value()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableTypeValueFieldSpecContext is an interface to support dynamic dispatch.
type IVariableTypeValueFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableTypeValueFieldSpecContext differentiates from other interfaces.
	IsVariableTypeValueFieldSpecContext()
}

type VariableTypeValueFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableTypeValueFieldSpecContext() *VariableTypeValueFieldSpecContext {
	var p = new(VariableTypeValueFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_variableTypeValueFieldSpec
	return p
}

func (*VariableTypeValueFieldSpecContext) IsVariableTypeValueFieldSpecContext() {}

func NewVariableTypeValueFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableTypeValueFieldSpecContext {
	var p = new(VariableTypeValueFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_variableTypeValueFieldSpec

	return p
}

func (s *VariableTypeValueFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableTypeValueFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *VariableTypeValueFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *VariableTypeValueFieldSpecContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *VariableTypeValueFieldSpecContext) ValueOptionalitySpec() IValueOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOptionalitySpecContext)
}

func (s *VariableTypeValueFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableTypeValueFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableTypeValueFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterVariableTypeValueFieldSpec(s)
	}
}

func (s *VariableTypeValueFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitVariableTypeValueFieldSpec(s)
	}
}

func (s *VariableTypeValueFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitVariableTypeValueFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) VariableTypeValueFieldSpec() (localctx IVariableTypeValueFieldSpecContext) {
	localctx = NewVariableTypeValueFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ASNParserRULE_variableTypeValueFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(663)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(664)
		p.FieldName()
	}
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(665)
			p.ValueOptionalitySpec()
		}

	}

	return localctx
}

// IFixedTypeValueSetFieldSpecContext is an interface to support dynamic dispatch.
type IFixedTypeValueSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixedTypeValueSetFieldSpecContext differentiates from other interfaces.
	IsFixedTypeValueSetFieldSpecContext()
}

type FixedTypeValueSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixedTypeValueSetFieldSpecContext() *FixedTypeValueSetFieldSpecContext {
	var p = new(FixedTypeValueSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_fixedTypeValueSetFieldSpec
	return p
}

func (*FixedTypeValueSetFieldSpecContext) IsFixedTypeValueSetFieldSpecContext() {}

func NewFixedTypeValueSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedTypeValueSetFieldSpecContext {
	var p = new(FixedTypeValueSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_fixedTypeValueSetFieldSpec

	return p
}

func (s *FixedTypeValueSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedTypeValueSetFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *FixedTypeValueSetFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *FixedTypeValueSetFieldSpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *FixedTypeValueSetFieldSpecContext) ValueSetOptionalitySpec() IValueSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetOptionalitySpecContext)
}

func (s *FixedTypeValueSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedTypeValueSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedTypeValueSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterFixedTypeValueSetFieldSpec(s)
	}
}

func (s *FixedTypeValueSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitFixedTypeValueSetFieldSpec(s)
	}
}

func (s *FixedTypeValueSetFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitFixedTypeValueSetFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) FixedTypeValueSetFieldSpec() (localctx IFixedTypeValueSetFieldSpecContext) {
	localctx = NewFixedTypeValueSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ASNParserRULE_fixedTypeValueSetFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(668)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(669)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(670)
		p.AsnType()
	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(671)
			p.ValueSetOptionalitySpec()
		}

	}

	return localctx
}

// IValueSetOptionalitySpecContext is an interface to support dynamic dispatch.
type IValueSetOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueSetOptionalitySpecContext differentiates from other interfaces.
	IsValueSetOptionalitySpecContext()
}

type ValueSetOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSetOptionalitySpecContext() *ValueSetOptionalitySpecContext {
	var p = new(ValueSetOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_valueSetOptionalitySpec
	return p
}

func (*ValueSetOptionalitySpecContext) IsValueSetOptionalitySpecContext() {}

func NewValueSetOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSetOptionalitySpecContext {
	var p = new(ValueSetOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_valueSetOptionalitySpec

	return p
}

func (s *ValueSetOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSetOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *ValueSetOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *ValueSetOptionalitySpecContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *ValueSetOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSetOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSetOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterValueSetOptionalitySpec(s)
	}
}

func (s *ValueSetOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitValueSetOptionalitySpec(s)
	}
}

func (s *ValueSetOptionalitySpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitValueSetOptionalitySpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ValueSetOptionalitySpec() (localctx IValueSetOptionalitySpecContext) {
	localctx = NewValueSetOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ASNParserRULE_valueSetOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(677)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(674)
			p.Match(ASNParserOPTIONAL_LITERAL)
		}

	case ASNParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(675)
			p.Match(ASNParserDEFAULT_LITERAL)
		}
		{
			p.SetState(676)
			p.ValueSet()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectContext is an interface to support dynamic dispatch.
type IObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectContext differentiates from other interfaces.
	IsObjectContext()
}

type ObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectContext() *ObjectContext {
	var p = new(ObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_object
	return p
}

func (*ObjectContext) IsObjectContext() {}

func NewObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectContext {
	var p = new(ObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_object

	return p
}

func (s *ObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectContext) DefinedObject() IDefinedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectContext)
}

func (s *ObjectContext) ParameterizedObject() IParameterizedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterizedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterizedObjectContext)
}

func (s *ObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObject(s)
	}
}

func (s *ObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObject(s)
	}
}

func (s *ObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Object() (localctx IObjectContext) {
	localctx = NewObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ASNParserRULE_object)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(679)
			p.DefinedObject()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(680)
			p.ParameterizedObject()
		}

	}

	return localctx
}

// IParameterizedObjectContext is an interface to support dynamic dispatch.
type IParameterizedObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterizedObjectContext differentiates from other interfaces.
	IsParameterizedObjectContext()
}

type ParameterizedObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterizedObjectContext() *ParameterizedObjectContext {
	var p = new(ParameterizedObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_parameterizedObject
	return p
}

func (*ParameterizedObjectContext) IsParameterizedObjectContext() {}

func NewParameterizedObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterizedObjectContext {
	var p = new(ParameterizedObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_parameterizedObject

	return p
}

func (s *ParameterizedObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterizedObjectContext) DefinedObject() IDefinedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectContext)
}

func (s *ParameterizedObjectContext) ActualParameterList() IActualParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualParameterListContext)
}

func (s *ParameterizedObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterizedObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterizedObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParameterizedObject(s)
	}
}

func (s *ParameterizedObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParameterizedObject(s)
	}
}

func (s *ParameterizedObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitParameterizedObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ParameterizedObject() (localctx IParameterizedObjectContext) {
	localctx = NewParameterizedObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ASNParserRULE_parameterizedObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.DefinedObject()
	}
	{
		p.SetState(684)
		p.ActualParameterList()
	}

	return localctx
}

// IDefinedObjectContext is an interface to support dynamic dispatch.
type IDefinedObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedObjectContext differentiates from other interfaces.
	IsDefinedObjectContext()
}

type DefinedObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedObjectContext() *DefinedObjectContext {
	var p = new(DefinedObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_definedObject
	return p
}

func (*DefinedObjectContext) IsDefinedObjectContext() {}

func NewDefinedObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedObjectContext {
	var p = new(DefinedObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_definedObject

	return p
}

func (s *DefinedObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedObjectContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *DefinedObjectContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *DefinedObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterDefinedObject(s)
	}
}

func (s *DefinedObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitDefinedObject(s)
	}
}

func (s *DefinedObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitDefinedObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) DefinedObject() (localctx IDefinedObjectContext) {
	localctx = NewDefinedObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ASNParserRULE_definedObject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserDOT {
		{
			p.SetState(687)
			p.Match(ASNParserDOT)
		}

	}

	return localctx
}

// IObjectSetContext is an interface to support dynamic dispatch.
type IObjectSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetContext differentiates from other interfaces.
	IsObjectSetContext()
}

type ObjectSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetContext() *ObjectSetContext {
	var p = new(ObjectSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectSet
	return p
}

func (*ObjectSetContext) IsObjectSetContext() {}

func NewObjectSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetContext {
	var p = new(ObjectSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectSet

	return p
}

func (s *ObjectSetContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ObjectSetContext) ObjectSetSpec() IObjectSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetSpecContext)
}

func (s *ObjectSetContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ObjectSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectSet(s)
	}
}

func (s *ObjectSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectSet(s)
	}
}

func (s *ObjectSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectSet() (localctx IObjectSetContext) {
	localctx = NewObjectSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ASNParserRULE_objectSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(691)
		p.ObjectSetSpec()
	}
	{
		p.SetState(692)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IObjectSetSpecContext is an interface to support dynamic dispatch.
type IObjectSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetSpecContext differentiates from other interfaces.
	IsObjectSetSpecContext()
}

type ObjectSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetSpecContext() *ObjectSetSpecContext {
	var p = new(ObjectSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectSetSpec
	return p
}

func (*ObjectSetSpecContext) IsObjectSetSpecContext() {}

func NewObjectSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetSpecContext {
	var p = new(ObjectSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectSetSpec

	return p
}

func (s *ObjectSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetSpecContext) RootElementSetSpec() IRootElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootElementSetSpecContext)
}

func (s *ObjectSetSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ObjectSetSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ObjectSetSpecContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *ObjectSetSpecContext) AdditionalElementSetSpec() IAdditionalElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditionalElementSetSpecContext)
}

func (s *ObjectSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectSetSpec(s)
	}
}

func (s *ObjectSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectSetSpec(s)
	}
}

func (s *ObjectSetSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectSetSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectSetSpec() (localctx IObjectSetSpecContext) {
	localctx = NewObjectSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ASNParserRULE_objectSetSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(708)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserTRUE_LITERAL, ASNParserFALSE_LITERAL, ASNParserTRUE_SMALL_LITERAL, ASNParserFALSE_SMALL_LITERAL, ASNParserL_BRACE, ASNParserMINUS, ASNParserALL_LITERAL, ASNParserMIN_LITERAL, ASNParserSIZE_LITERAL, ASNParserPATTERN_LITERAL, ASNParserNUMBER, ASNParserCSTRING, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(694)
			p.RootElementSetSpec()
		}
		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(695)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(696)
				p.Match(ASNParserELLIPSIS)
			}
			p.SetState(699)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASNParserCOMMA {
				{
					p.SetState(697)
					p.Match(ASNParserCOMMA)
				}
				{
					p.SetState(698)
					p.AdditionalElementSetSpec()
				}

			}

		}

	case ASNParserELLIPSIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(703)
			p.Match(ASNParserELLIPSIS)
		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(704)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(705)
				p.AdditionalElementSetSpec()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFieldNameContext is an interface to support dynamic dispatch.
type IFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldNameContext differentiates from other interfaces.
	IsFieldNameContext()
}

type FieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameContext() *FieldNameContext {
	var p = new(FieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_fieldName
	return p
}

func (*FieldNameContext) IsFieldNameContext() {}

func NewFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameContext {
	var p = new(FieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_fieldName

	return p
}

func (s *FieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameContext) AllAMPERSAND() []antlr.TerminalNode {
	return s.GetTokens(ASNParserAMPERSAND)
}

func (s *FieldNameContext) AMPERSAND(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, i)
}

func (s *FieldNameContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *FieldNameContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *FieldNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ASNParserDOT)
}

func (s *FieldNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, i)
}

func (s *FieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterFieldName(s)
	}
}

func (s *FieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitFieldName(s)
	}
}

func (s *FieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) FieldName() (localctx IFieldNameContext) {
	localctx = NewFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ASNParserRULE_fieldName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(711)
		p.Match(ASNParserIDENTIFIER)
	}

	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserAMPERSAND {
		{
			p.SetState(713)
			p.Match(ASNParserAMPERSAND)
		}
		{
			p.SetState(714)
			p.Match(ASNParserIDENTIFIER)
		}
		{
			p.SetState(715)
			p.Match(ASNParserDOT)
		}

		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IValueSetContext is an interface to support dynamic dispatch.
type IValueSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueSetContext differentiates from other interfaces.
	IsValueSetContext()
}

type ValueSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSetContext() *ValueSetContext {
	var p = new(ValueSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_valueSet
	return p
}

func (*ValueSetContext) IsValueSetContext() {}

func NewValueSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSetContext {
	var p = new(ValueSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_valueSet

	return p
}

func (s *ValueSetContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSetContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ValueSetContext) ElementSetSpecs() IElementSetSpecsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecsContext)
}

func (s *ValueSetContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ValueSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterValueSet(s)
	}
}

func (s *ValueSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitValueSet(s)
	}
}

func (s *ValueSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitValueSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ValueSet() (localctx IValueSetContext) {
	localctx = NewValueSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ASNParserRULE_valueSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(722)
		p.ElementSetSpecs()
	}
	{
		p.SetState(723)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IElementSetSpecsContext is an interface to support dynamic dispatch.
type IElementSetSpecsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementSetSpecsContext differentiates from other interfaces.
	IsElementSetSpecsContext()
}

type ElementSetSpecsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementSetSpecsContext() *ElementSetSpecsContext {
	var p = new(ElementSetSpecsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_elementSetSpecs
	return p
}

func (*ElementSetSpecsContext) IsElementSetSpecsContext() {}

func NewElementSetSpecsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementSetSpecsContext {
	var p = new(ElementSetSpecsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_elementSetSpecs

	return p
}

func (s *ElementSetSpecsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementSetSpecsContext) RootElementSetSpec() IRootElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootElementSetSpecContext)
}

func (s *ElementSetSpecsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ElementSetSpecsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ElementSetSpecsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *ElementSetSpecsContext) AdditionalElementSetSpec() IAdditionalElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditionalElementSetSpecContext)
}

func (s *ElementSetSpecsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementSetSpecsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementSetSpecsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterElementSetSpecs(s)
	}
}

func (s *ElementSetSpecsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitElementSetSpecs(s)
	}
}

func (s *ElementSetSpecsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitElementSetSpecs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ElementSetSpecs() (localctx IElementSetSpecsContext) {
	localctx = NewElementSetSpecsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ASNParserRULE_elementSetSpecs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(725)
		p.RootElementSetSpec()
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserCOMMA {
		{
			p.SetState(726)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(727)
			p.Match(ASNParserELLIPSIS)
		}
		p.SetState(730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(728)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(729)
				p.AdditionalElementSetSpec()
			}

		}

	}

	return localctx
}

// IRootElementSetSpecContext is an interface to support dynamic dispatch.
type IRootElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootElementSetSpecContext differentiates from other interfaces.
	IsRootElementSetSpecContext()
}

type RootElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootElementSetSpecContext() *RootElementSetSpecContext {
	var p = new(RootElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_rootElementSetSpec
	return p
}

func (*RootElementSetSpecContext) IsRootElementSetSpecContext() {}

func NewRootElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootElementSetSpecContext {
	var p = new(RootElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_rootElementSetSpec

	return p
}

func (s *RootElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RootElementSetSpecContext) ElementSetSpec() IElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecContext)
}

func (s *RootElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterRootElementSetSpec(s)
	}
}

func (s *RootElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitRootElementSetSpec(s)
	}
}

func (s *RootElementSetSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitRootElementSetSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) RootElementSetSpec() (localctx IRootElementSetSpecContext) {
	localctx = NewRootElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ASNParserRULE_rootElementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		p.ElementSetSpec()
	}

	return localctx
}

// IAdditionalElementSetSpecContext is an interface to support dynamic dispatch.
type IAdditionalElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditionalElementSetSpecContext differentiates from other interfaces.
	IsAdditionalElementSetSpecContext()
}

type AdditionalElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditionalElementSetSpecContext() *AdditionalElementSetSpecContext {
	var p = new(AdditionalElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_additionalElementSetSpec
	return p
}

func (*AdditionalElementSetSpecContext) IsAdditionalElementSetSpecContext() {}

func NewAdditionalElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditionalElementSetSpecContext {
	var p = new(AdditionalElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_additionalElementSetSpec

	return p
}

func (s *AdditionalElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditionalElementSetSpecContext) ElementSetSpec() IElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecContext)
}

func (s *AdditionalElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionalElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditionalElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAdditionalElementSetSpec(s)
	}
}

func (s *AdditionalElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAdditionalElementSetSpec(s)
	}
}

func (s *AdditionalElementSetSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitAdditionalElementSetSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) AdditionalElementSetSpec() (localctx IAdditionalElementSetSpecContext) {
	localctx = NewAdditionalElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ASNParserRULE_additionalElementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		p.ElementSetSpec()
	}

	return localctx
}

// IElementSetSpecContext is an interface to support dynamic dispatch.
type IElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementSetSpecContext differentiates from other interfaces.
	IsElementSetSpecContext()
}

type ElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementSetSpecContext() *ElementSetSpecContext {
	var p = new(ElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_elementSetSpec
	return p
}

func (*ElementSetSpecContext) IsElementSetSpecContext() {}

func NewElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementSetSpecContext {
	var p = new(ElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_elementSetSpec

	return p
}

func (s *ElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementSetSpecContext) Unions() IUnionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionsContext)
}

func (s *ElementSetSpecContext) ALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserALL_LITERAL, 0)
}

func (s *ElementSetSpecContext) Exclusions() IExclusionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusionsContext)
}

func (s *ElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterElementSetSpec(s)
	}
}

func (s *ElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitElementSetSpec(s)
	}
}

func (s *ElementSetSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitElementSetSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ElementSetSpec() (localctx IElementSetSpecContext) {
	localctx = NewElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ASNParserRULE_elementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(741)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserTRUE_LITERAL, ASNParserFALSE_LITERAL, ASNParserTRUE_SMALL_LITERAL, ASNParserFALSE_SMALL_LITERAL, ASNParserL_BRACE, ASNParserMINUS, ASNParserMIN_LITERAL, ASNParserSIZE_LITERAL, ASNParserPATTERN_LITERAL, ASNParserNUMBER, ASNParserCSTRING, ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(738)
			p.Unions()
		}

	case ASNParserALL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(739)
			p.Match(ASNParserALL_LITERAL)
		}
		{
			p.SetState(740)
			p.Exclusions()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnionsContext is an interface to support dynamic dispatch.
type IUnionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionsContext differentiates from other interfaces.
	IsUnionsContext()
}

type UnionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionsContext() *UnionsContext {
	var p = new(UnionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_unions
	return p
}

func (*UnionsContext) IsUnionsContext() {}

func NewUnionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionsContext {
	var p = new(UnionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_unions

	return p
}

func (s *UnionsContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionsContext) AllIntersections() []IIntersectionsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntersectionsContext)(nil)).Elem())
	var tst = make([]IIntersectionsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntersectionsContext)
		}
	}

	return tst
}

func (s *UnionsContext) Intersections(i int) IIntersectionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntersectionsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntersectionsContext)
}

func (s *UnionsContext) AllUnionMark() []IUnionMarkContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionMarkContext)(nil)).Elem())
	var tst = make([]IUnionMarkContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionMarkContext)
		}
	}

	return tst
}

func (s *UnionsContext) UnionMark(i int) IUnionMarkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMarkContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionMarkContext)
}

func (s *UnionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterUnions(s)
	}
}

func (s *UnionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitUnions(s)
	}
}

func (s *UnionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitUnions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Unions() (localctx IUnionsContext) {
	localctx = NewUnionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ASNParserRULE_unions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Intersections()
	}

	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserPIPE || _la == ASNParserUNION_LITERAL {
		{
			p.SetState(744)
			p.UnionMark()
		}
		{
			p.SetState(745)
			p.Intersections()
		}

		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExclusionsContext is an interface to support dynamic dispatch.
type IExclusionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusionsContext differentiates from other interfaces.
	IsExclusionsContext()
}

type ExclusionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusionsContext() *ExclusionsContext {
	var p = new(ExclusionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_exclusions
	return p
}

func (*ExclusionsContext) IsExclusionsContext() {}

func NewExclusionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusionsContext {
	var p = new(ExclusionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_exclusions

	return p
}

func (s *ExclusionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclusionsContext) EXCEPT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserEXCEPT_LITERAL, 0)
}

func (s *ExclusionsContext) Elements() IElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementsContext)
}

func (s *ExclusionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclusionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExclusions(s)
	}
}

func (s *ExclusionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExclusions(s)
	}
}

func (s *ExclusionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExclusions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Exclusions() (localctx IExclusionsContext) {
	localctx = NewExclusionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ASNParserRULE_exclusions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(752)
		p.Match(ASNParserEXCEPT_LITERAL)
	}
	{
		p.SetState(753)
		p.Elements()
	}

	return localctx
}

// IIntersectionsContext is an interface to support dynamic dispatch.
type IIntersectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntersectionsContext differentiates from other interfaces.
	IsIntersectionsContext()
}

type IntersectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectionsContext() *IntersectionsContext {
	var p = new(IntersectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_intersections
	return p
}

func (*IntersectionsContext) IsIntersectionsContext() {}

func NewIntersectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectionsContext {
	var p = new(IntersectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_intersections

	return p
}

func (s *IntersectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectionsContext) AllIntersectionElements() []IIntersectionElementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntersectionElementsContext)(nil)).Elem())
	var tst = make([]IIntersectionElementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntersectionElementsContext)
		}
	}

	return tst
}

func (s *IntersectionsContext) IntersectionElements(i int) IIntersectionElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntersectionElementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntersectionElementsContext)
}

func (s *IntersectionsContext) AllIntersectionMark() []IIntersectionMarkContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntersectionMarkContext)(nil)).Elem())
	var tst = make([]IIntersectionMarkContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntersectionMarkContext)
		}
	}

	return tst
}

func (s *IntersectionsContext) IntersectionMark(i int) IIntersectionMarkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntersectionMarkContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntersectionMarkContext)
}

func (s *IntersectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterIntersections(s)
	}
}

func (s *IntersectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitIntersections(s)
	}
}

func (s *IntersectionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitIntersections(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Intersections() (localctx IIntersectionsContext) {
	localctx = NewIntersectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ASNParserRULE_intersections)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.IntersectionElements()
	}

	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserPOWER || _la == ASNParserINTERSECTION_LITERAL {
		{
			p.SetState(756)
			p.IntersectionMark()
		}
		{
			p.SetState(757)
			p.IntersectionElements()
		}

		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnionMarkContext is an interface to support dynamic dispatch.
type IUnionMarkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionMarkContext differentiates from other interfaces.
	IsUnionMarkContext()
}

type UnionMarkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionMarkContext() *UnionMarkContext {
	var p = new(UnionMarkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_unionMark
	return p
}

func (*UnionMarkContext) IsUnionMarkContext() {}

func NewUnionMarkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionMarkContext {
	var p = new(UnionMarkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_unionMark

	return p
}

func (s *UnionMarkContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionMarkContext) PIPE() antlr.TerminalNode {
	return s.GetToken(ASNParserPIPE, 0)
}

func (s *UnionMarkContext) UNION_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserUNION_LITERAL, 0)
}

func (s *UnionMarkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionMarkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionMarkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterUnionMark(s)
	}
}

func (s *UnionMarkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitUnionMark(s)
	}
}

func (s *UnionMarkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitUnionMark(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) UnionMark() (localctx IUnionMarkContext) {
	localctx = NewUnionMarkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ASNParserRULE_unionMark)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASNParserPIPE || _la == ASNParserUNION_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntersectionMarkContext is an interface to support dynamic dispatch.
type IIntersectionMarkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntersectionMarkContext differentiates from other interfaces.
	IsIntersectionMarkContext()
}

type IntersectionMarkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectionMarkContext() *IntersectionMarkContext {
	var p = new(IntersectionMarkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_intersectionMark
	return p
}

func (*IntersectionMarkContext) IsIntersectionMarkContext() {}

func NewIntersectionMarkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectionMarkContext {
	var p = new(IntersectionMarkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_intersectionMark

	return p
}

func (s *IntersectionMarkContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectionMarkContext) POWER() antlr.TerminalNode {
	return s.GetToken(ASNParserPOWER, 0)
}

func (s *IntersectionMarkContext) INTERSECTION_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserINTERSECTION_LITERAL, 0)
}

func (s *IntersectionMarkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionMarkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectionMarkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterIntersectionMark(s)
	}
}

func (s *IntersectionMarkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitIntersectionMark(s)
	}
}

func (s *IntersectionMarkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitIntersectionMark(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) IntersectionMark() (localctx IIntersectionMarkContext) {
	localctx = NewIntersectionMarkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ASNParserRULE_intersectionMark)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASNParserPOWER || _la == ASNParserINTERSECTION_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IElementsContext is an interface to support dynamic dispatch.
type IElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementsContext differentiates from other interfaces.
	IsElementsContext()
}

type ElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementsContext() *ElementsContext {
	var p = new(ElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_elements
	return p
}

func (*ElementsContext) IsElementsContext() {}

func NewElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementsContext {
	var p = new(ElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_elements

	return p
}

func (s *ElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementsContext) SubtypeElements() ISubtypeElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtypeElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtypeElementsContext)
}

func (s *ElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterElements(s)
	}
}

func (s *ElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitElements(s)
	}
}

func (s *ElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Elements() (localctx IElementsContext) {
	localctx = NewElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ASNParserRULE_elements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.SubtypeElements()
	}

	return localctx
}

// IObjectSetElementsContext is an interface to support dynamic dispatch.
type IObjectSetElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetElementsContext differentiates from other interfaces.
	IsObjectSetElementsContext()
}

type ObjectSetElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetElementsContext() *ObjectSetElementsContext {
	var p = new(ObjectSetElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectSetElements
	return p
}

func (*ObjectSetElementsContext) IsObjectSetElementsContext() {}

func NewObjectSetElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetElementsContext {
	var p = new(ObjectSetElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectSetElements

	return p
}

func (s *ObjectSetElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetElementsContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *ObjectSetElementsContext) DefinedObject() IDefinedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectContext)
}

func (s *ObjectSetElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectSetElements(s)
	}
}

func (s *ObjectSetElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectSetElements(s)
	}
}

func (s *ObjectSetElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectSetElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectSetElements() (localctx IObjectSetElementsContext) {
	localctx = NewObjectSetElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ASNParserRULE_objectSetElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(770)
			p.Object()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(771)
			p.DefinedObject()
		}

	}

	return localctx
}

// IIntersectionElementsContext is an interface to support dynamic dispatch.
type IIntersectionElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntersectionElementsContext differentiates from other interfaces.
	IsIntersectionElementsContext()
}

type IntersectionElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectionElementsContext() *IntersectionElementsContext {
	var p = new(IntersectionElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_intersectionElements
	return p
}

func (*IntersectionElementsContext) IsIntersectionElementsContext() {}

func NewIntersectionElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectionElementsContext {
	var p = new(IntersectionElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_intersectionElements

	return p
}

func (s *IntersectionElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectionElementsContext) Elements() IElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementsContext)
}

func (s *IntersectionElementsContext) Exclusions() IExclusionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusionsContext)
}

func (s *IntersectionElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectionElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterIntersectionElements(s)
	}
}

func (s *IntersectionElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitIntersectionElements(s)
	}
}

func (s *IntersectionElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitIntersectionElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) IntersectionElements() (localctx IIntersectionElementsContext) {
	localctx = NewIntersectionElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ASNParserRULE_intersectionElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		p.Elements()
	}
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserEXCEPT_LITERAL {
		{
			p.SetState(775)
			p.Exclusions()
		}

	}

	return localctx
}

// ISubtypeElementsContext is an interface to support dynamic dispatch.
type ISubtypeElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtypeElementsContext differentiates from other interfaces.
	IsSubtypeElementsContext()
}

type SubtypeElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtypeElementsContext() *SubtypeElementsContext {
	var p = new(SubtypeElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_subtypeElements
	return p
}

func (*SubtypeElementsContext) IsSubtypeElementsContext() {}

func NewSubtypeElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtypeElementsContext {
	var p = new(SubtypeElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_subtypeElements

	return p
}

func (s *SubtypeElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtypeElementsContext) DOUBLE_DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOUBLE_DOT, 0)
}

func (s *SubtypeElementsContext) AllValue() []IValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueContext)(nil)).Elem())
	var tst = make([]IValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueContext)
		}
	}

	return tst
}

func (s *SubtypeElementsContext) Value(i int) IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *SubtypeElementsContext) MIN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserMIN_LITERAL, 0)
}

func (s *SubtypeElementsContext) MAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserMAX_LITERAL, 0)
}

func (s *SubtypeElementsContext) AllLESS_THAN() []antlr.TerminalNode {
	return s.GetTokens(ASNParserLESS_THAN)
}

func (s *SubtypeElementsContext) LESS_THAN(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserLESS_THAN, i)
}

func (s *SubtypeElementsContext) SizeConstraint() ISizeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISizeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISizeConstraintContext)
}

func (s *SubtypeElementsContext) PATTERN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserPATTERN_LITERAL, 0)
}

func (s *SubtypeElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtypeElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtypeElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSubtypeElements(s)
	}
}

func (s *SubtypeElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSubtypeElements(s)
	}
}

func (s *SubtypeElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSubtypeElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SubtypeElements() (localctx ISubtypeElementsContext) {
	localctx = NewSubtypeElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ASNParserRULE_subtypeElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(780)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserTRUE_LITERAL, ASNParserFALSE_LITERAL, ASNParserTRUE_SMALL_LITERAL, ASNParserFALSE_SMALL_LITERAL, ASNParserL_BRACE, ASNParserMINUS, ASNParserNUMBER, ASNParserCSTRING, ASNParserIDENTIFIER:
			{
				p.SetState(778)
				p.Value()
			}

		case ASNParserMIN_LITERAL:
			{
				p.SetState(779)
				p.Match(ASNParserMIN_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserLESS_THAN {
			{
				p.SetState(782)
				p.Match(ASNParserLESS_THAN)
			}

		}
		{
			p.SetState(785)
			p.Match(ASNParserDOUBLE_DOT)
		}
		p.SetState(787)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserLESS_THAN {
			{
				p.SetState(786)
				p.Match(ASNParserLESS_THAN)
			}

		}
		p.SetState(791)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASNParserTRUE_LITERAL, ASNParserFALSE_LITERAL, ASNParserTRUE_SMALL_LITERAL, ASNParserFALSE_SMALL_LITERAL, ASNParserL_BRACE, ASNParserMINUS, ASNParserNUMBER, ASNParserCSTRING, ASNParserIDENTIFIER:
			{
				p.SetState(789)
				p.Value()
			}

		case ASNParserMAX_LITERAL:
			{
				p.SetState(790)
				p.Match(ASNParserMAX_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(793)
			p.SizeConstraint()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(794)
			p.Match(ASNParserPATTERN_LITERAL)
		}
		{
			p.SetState(795)
			p.Value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(796)
			p.Value()
		}

	}

	return localctx
}

// IVariableTypeValueSetFieldSpecContext is an interface to support dynamic dispatch.
type IVariableTypeValueSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableTypeValueSetFieldSpecContext differentiates from other interfaces.
	IsVariableTypeValueSetFieldSpecContext()
}

type VariableTypeValueSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableTypeValueSetFieldSpecContext() *VariableTypeValueSetFieldSpecContext {
	var p = new(VariableTypeValueSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_variableTypeValueSetFieldSpec
	return p
}

func (*VariableTypeValueSetFieldSpecContext) IsVariableTypeValueSetFieldSpecContext() {}

func NewVariableTypeValueSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableTypeValueSetFieldSpecContext {
	var p = new(VariableTypeValueSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_variableTypeValueSetFieldSpec

	return p
}

func (s *VariableTypeValueSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableTypeValueSetFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *VariableTypeValueSetFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *VariableTypeValueSetFieldSpecContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *VariableTypeValueSetFieldSpecContext) ValueSetOptionalitySpec() IValueSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetOptionalitySpecContext)
}

func (s *VariableTypeValueSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableTypeValueSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableTypeValueSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterVariableTypeValueSetFieldSpec(s)
	}
}

func (s *VariableTypeValueSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitVariableTypeValueSetFieldSpec(s)
	}
}

func (s *VariableTypeValueSetFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitVariableTypeValueSetFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) VariableTypeValueSetFieldSpec() (localctx IVariableTypeValueSetFieldSpecContext) {
	localctx = NewVariableTypeValueSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ASNParserRULE_variableTypeValueSetFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(799)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(800)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(801)
		p.FieldName()
	}
	p.SetState(803)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(802)
			p.ValueSetOptionalitySpec()
		}

	}

	return localctx
}

// IObjectFieldSpecContext is an interface to support dynamic dispatch.
type IObjectFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectFieldSpecContext differentiates from other interfaces.
	IsObjectFieldSpecContext()
}

type ObjectFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldSpecContext() *ObjectFieldSpecContext {
	var p = new(ObjectFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectFieldSpec
	return p
}

func (*ObjectFieldSpecContext) IsObjectFieldSpecContext() {}

func NewObjectFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldSpecContext {
	var p = new(ObjectFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectFieldSpec

	return p
}

func (s *ObjectFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *ObjectFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ObjectFieldSpecContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectFieldSpecContext) ObjectOptionalitySpec() IObjectOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectOptionalitySpecContext)
}

func (s *ObjectFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectFieldSpec(s)
	}
}

func (s *ObjectFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectFieldSpec(s)
	}
}

func (s *ObjectFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectFieldSpec() (localctx IObjectFieldSpecContext) {
	localctx = NewObjectFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ASNParserRULE_objectFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(805)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(806)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(807)
		p.DefinedObjectClass()
	}
	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(808)
			p.ObjectOptionalitySpec()
		}

	}

	return localctx
}

// IObjectOptionalitySpecContext is an interface to support dynamic dispatch.
type IObjectOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectOptionalitySpecContext differentiates from other interfaces.
	IsObjectOptionalitySpecContext()
}

type ObjectOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectOptionalitySpecContext() *ObjectOptionalitySpecContext {
	var p = new(ObjectOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectOptionalitySpec
	return p
}

func (*ObjectOptionalitySpecContext) IsObjectOptionalitySpecContext() {}

func NewObjectOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectOptionalitySpecContext {
	var p = new(ObjectOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectOptionalitySpec

	return p
}

func (s *ObjectOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *ObjectOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *ObjectOptionalitySpecContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *ObjectOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectOptionalitySpec(s)
	}
}

func (s *ObjectOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectOptionalitySpec(s)
	}
}

func (s *ObjectOptionalitySpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectOptionalitySpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectOptionalitySpec() (localctx IObjectOptionalitySpecContext) {
	localctx = NewObjectOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ASNParserRULE_objectOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(814)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(811)
			p.Match(ASNParserOPTIONAL_LITERAL)
		}

	case ASNParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(812)
			p.Match(ASNParserDEFAULT_LITERAL)
		}
		{
			p.SetState(813)
			p.Object()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectSetFieldSpecContext is an interface to support dynamic dispatch.
type IObjectSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetFieldSpecContext differentiates from other interfaces.
	IsObjectSetFieldSpecContext()
}

type ObjectSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetFieldSpecContext() *ObjectSetFieldSpecContext {
	var p = new(ObjectSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectSetFieldSpec
	return p
}

func (*ObjectSetFieldSpecContext) IsObjectSetFieldSpecContext() {}

func NewObjectSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetFieldSpecContext {
	var p = new(ObjectSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectSetFieldSpec

	return p
}

func (s *ObjectSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASNParserAMPERSAND, 0)
}

func (s *ObjectSetFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ObjectSetFieldSpecContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectSetFieldSpecContext) ObjectSetOptionalitySpec() IObjectSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetOptionalitySpecContext)
}

func (s *ObjectSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectSetFieldSpec(s)
	}
}

func (s *ObjectSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectSetFieldSpec(s)
	}
}

func (s *ObjectSetFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectSetFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectSetFieldSpec() (localctx IObjectSetFieldSpecContext) {
	localctx = NewObjectSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ASNParserRULE_objectSetFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Match(ASNParserAMPERSAND)
	}
	{
		p.SetState(817)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(818)
		p.DefinedObjectClass()
	}
	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserOPTIONAL_LITERAL || _la == ASNParserDEFAULT_LITERAL {
		{
			p.SetState(819)
			p.ObjectSetOptionalitySpec()
		}

	}

	return localctx
}

// IObjectSetOptionalitySpecContext is an interface to support dynamic dispatch.
type IObjectSetOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetOptionalitySpecContext differentiates from other interfaces.
	IsObjectSetOptionalitySpecContext()
}

type ObjectSetOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetOptionalitySpecContext() *ObjectSetOptionalitySpecContext {
	var p = new(ObjectSetOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectSetOptionalitySpec
	return p
}

func (*ObjectSetOptionalitySpecContext) IsObjectSetOptionalitySpecContext() {}

func NewObjectSetOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetOptionalitySpecContext {
	var p = new(ObjectSetOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectSetOptionalitySpec

	return p
}

func (s *ObjectSetOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOPTIONAL_LITERAL, 0)
}

func (s *ObjectSetOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserDEFAULT_LITERAL, 0)
}

func (s *ObjectSetOptionalitySpecContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *ObjectSetOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectSetOptionalitySpec(s)
	}
}

func (s *ObjectSetOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectSetOptionalitySpec(s)
	}
}

func (s *ObjectSetOptionalitySpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectSetOptionalitySpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectSetOptionalitySpec() (localctx IObjectSetOptionalitySpecContext) {
	localctx = NewObjectSetOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ASNParserRULE_objectSetOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(825)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(822)
			p.Match(ASNParserOPTIONAL_LITERAL)
		}

	case ASNParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(823)
			p.Match(ASNParserDEFAULT_LITERAL)
		}
		{
			p.SetState(824)
			p.ObjectSet()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeAssignmentContext is an interface to support dynamic dispatch.
type ITypeAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAssignmentContext differentiates from other interfaces.
	IsTypeAssignmentContext()
}

type TypeAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAssignmentContext() *TypeAssignmentContext {
	var p = new(TypeAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_typeAssignment
	return p
}

func (*TypeAssignmentContext) IsTypeAssignmentContext() {}

func NewTypeAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAssignmentContext {
	var p = new(TypeAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_typeAssignment

	return p
}

func (s *TypeAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASNParserASSIGN_OP, 0)
}

func (s *TypeAssignmentContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *TypeAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTypeAssignment(s)
	}
}

func (s *TypeAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTypeAssignment(s)
	}
}

func (s *TypeAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitTypeAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) TypeAssignment() (localctx ITypeAssignmentContext) {
	localctx = NewTypeAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ASNParserRULE_typeAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.Match(ASNParserASSIGN_OP)
	}
	{
		p.SetState(828)
		p.AsnType()
	}

	return localctx
}

// IValueAssignmentContext is an interface to support dynamic dispatch.
type IValueAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueAssignmentContext differentiates from other interfaces.
	IsValueAssignmentContext()
}

type ValueAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueAssignmentContext() *ValueAssignmentContext {
	var p = new(ValueAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_valueAssignment
	return p
}

func (*ValueAssignmentContext) IsValueAssignmentContext() {}

func NewValueAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueAssignmentContext {
	var p = new(ValueAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_valueAssignment

	return p
}

func (s *ValueAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueAssignmentContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ValueAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASNParserASSIGN_OP, 0)
}

func (s *ValueAssignmentContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ValueAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterValueAssignment(s)
	}
}

func (s *ValueAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitValueAssignment(s)
	}
}

func (s *ValueAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitValueAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ValueAssignment() (localctx IValueAssignmentContext) {
	localctx = NewValueAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ASNParserRULE_valueAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(830)
		p.AsnType()
	}
	{
		p.SetState(831)
		p.Match(ASNParserASSIGN_OP)
	}
	{
		p.SetState(832)
		p.Value()
	}

	return localctx
}

// IAsnTypeContext is an interface to support dynamic dispatch.
type IAsnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsnTypeContext differentiates from other interfaces.
	IsAsnTypeContext()
}

type AsnTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsnTypeContext() *AsnTypeContext {
	var p = new(AsnTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_asnType
	return p
}

func (*AsnTypeContext) IsAsnTypeContext() {}

func NewAsnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsnTypeContext {
	var p = new(AsnTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_asnType

	return p
}

func (s *AsnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AsnTypeContext) BuiltinType() IBuiltinTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBuiltinTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBuiltinTypeContext)
}

func (s *AsnTypeContext) ReferencedType() IReferencedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferencedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferencedTypeContext)
}

func (s *AsnTypeContext) AllConstraint() []IConstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstraintContext)(nil)).Elem())
	var tst = make([]IConstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstraintContext)
		}
	}

	return tst
}

func (s *AsnTypeContext) Constraint(i int) IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *AsnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAsnType(s)
	}
}

func (s *AsnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAsnType(s)
	}
}

func (s *AsnTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitAsnType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) AsnType() (localctx IAsnTypeContext) {
	localctx = NewAsnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ASNParserRULE_asnType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(834)
			p.BuiltinType()
		}

	case 2:
		{
			p.SetState(835)
			p.ReferencedType()
		}

	}
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(838)
				p.Constraint()
			}

		}
		p.SetState(843)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
	}

	return localctx
}

// IBuiltinTypeContext is an interface to support dynamic dispatch.
type IBuiltinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBuiltinTypeContext differentiates from other interfaces.
	IsBuiltinTypeContext()
}

type BuiltinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltinTypeContext() *BuiltinTypeContext {
	var p = new(BuiltinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_builtinType
	return p
}

func (*BuiltinTypeContext) IsBuiltinTypeContext() {}

func NewBuiltinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltinTypeContext {
	var p = new(BuiltinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_builtinType

	return p
}

func (s *BuiltinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltinTypeContext) OctetStringType() IOctetStringTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctetStringTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctetStringTypeContext)
}

func (s *BuiltinTypeContext) BitStringType() IBitStringTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitStringTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitStringTypeContext)
}

func (s *BuiltinTypeContext) ChoiceType() IChoiceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoiceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoiceTypeContext)
}

func (s *BuiltinTypeContext) EnumeratedType() IEnumeratedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratedTypeContext)
}

func (s *BuiltinTypeContext) IntegerType() IIntegerTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerTypeContext)
}

func (s *BuiltinTypeContext) SequenceType() ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *BuiltinTypeContext) SequenceOfType() ISequenceOfTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceOfTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceOfTypeContext)
}

func (s *BuiltinTypeContext) SetType() ISetTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *BuiltinTypeContext) SetOfType() ISetOfTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetOfTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetOfTypeContext)
}

func (s *BuiltinTypeContext) Objectidentifiertype() IObjectidentifiertypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectidentifiertypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectidentifiertypeContext)
}

func (s *BuiltinTypeContext) ObjectClassFieldType() IObjectClassFieldTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassFieldTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassFieldTypeContext)
}

func (s *BuiltinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterBuiltinType(s)
	}
}

func (s *BuiltinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitBuiltinType(s)
	}
}

func (s *BuiltinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitBuiltinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) BuiltinType() (localctx IBuiltinTypeContext) {
	localctx = NewBuiltinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ASNParserRULE_builtinType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(844)
			p.OctetStringType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(845)
			p.BitStringType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(846)
			p.ChoiceType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(847)
			p.EnumeratedType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(848)
			p.IntegerType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(849)
			p.SequenceType()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(850)
			p.SequenceOfType()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(851)
			p.SetType()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(852)
			p.SetOfType()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(853)
			p.Objectidentifiertype()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(854)
			p.ObjectClassFieldType()
		}

	}

	return localctx
}

// IObjectClassFieldTypeContext is an interface to support dynamic dispatch.
type IObjectClassFieldTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassFieldTypeContext differentiates from other interfaces.
	IsObjectClassFieldTypeContext()
}

type ObjectClassFieldTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassFieldTypeContext() *ObjectClassFieldTypeContext {
	var p = new(ObjectClassFieldTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectClassFieldType
	return p
}

func (*ObjectClassFieldTypeContext) IsObjectClassFieldTypeContext() {}

func NewObjectClassFieldTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassFieldTypeContext {
	var p = new(ObjectClassFieldTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectClassFieldType

	return p
}

func (s *ObjectClassFieldTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassFieldTypeContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectClassFieldTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *ObjectClassFieldTypeContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *ObjectClassFieldTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassFieldTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassFieldTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectClassFieldType(s)
	}
}

func (s *ObjectClassFieldTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectClassFieldType(s)
	}
}

func (s *ObjectClassFieldTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectClassFieldType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectClassFieldType() (localctx IObjectClassFieldTypeContext) {
	localctx = NewObjectClassFieldTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ASNParserRULE_objectClassFieldType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(857)
		p.DefinedObjectClass()
	}
	{
		p.SetState(858)
		p.Match(ASNParserDOT)
	}
	{
		p.SetState(859)
		p.FieldName()
	}

	return localctx
}

// ISetTypeContext is an interface to support dynamic dispatch.
type ISetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetTypeContext differentiates from other interfaces.
	IsSetTypeContext()
}

type SetTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTypeContext() *SetTypeContext {
	var p = new(SetTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_setType
	return p
}

func (*SetTypeContext) IsSetTypeContext() {}

func NewSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTypeContext {
	var p = new(SetTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_setType

	return p
}

func (s *SetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTypeContext) SET_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSET_LITERAL, 0)
}

func (s *SetTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *SetTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *SetTypeContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *SetTypeContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *SetTypeContext) ComponentTypeLists() IComponentTypeListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListsContext)
}

func (s *SetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSetType(s)
	}
}

func (s *SetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSetType(s)
	}
}

func (s *SetTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSetType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SetType() (localctx ISetTypeContext) {
	localctx = NewSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ASNParserRULE_setType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		p.Match(ASNParserSET_LITERAL)
	}
	{
		p.SetState(862)
		p.Match(ASNParserL_BRACE)
	}
	p.SetState(867)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(863)
			p.ExtensionAndException()
		}
		{
			p.SetState(864)
			p.OptionalExtensionMarker()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(866)
			p.ComponentTypeLists()
		}

	}
	{
		p.SetState(869)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// ISetOfTypeContext is an interface to support dynamic dispatch.
type ISetOfTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetOfTypeContext differentiates from other interfaces.
	IsSetOfTypeContext()
}

type SetOfTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetOfTypeContext() *SetOfTypeContext {
	var p = new(SetOfTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_setOfType
	return p
}

func (*SetOfTypeContext) IsSetOfTypeContext() {}

func NewSetOfTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetOfTypeContext {
	var p = new(SetOfTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_setOfType

	return p
}

func (s *SetOfTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetOfTypeContext) SET_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSET_LITERAL, 0)
}

func (s *SetOfTypeContext) OF_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOF_LITERAL, 0)
}

func (s *SetOfTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *SetOfTypeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *SetOfTypeContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *SetOfTypeContext) SizeConstraint() ISizeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISizeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISizeConstraintContext)
}

func (s *SetOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOfTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSetOfType(s)
	}
}

func (s *SetOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSetOfType(s)
	}
}

func (s *SetOfTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSetOfType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SetOfType() (localctx ISetOfTypeContext) {
	localctx = NewSetOfTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ASNParserRULE_setOfType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)
		p.Match(ASNParserSET_LITERAL)
	}
	p.SetState(874)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserL_PARAN:
		{
			p.SetState(872)
			p.Constraint()
		}

	case ASNParserSIZE_LITERAL:
		{
			p.SetState(873)
			p.SizeConstraint()
		}

	case ASNParserOF_LITERAL:

	default:
	}
	{
		p.SetState(876)
		p.Match(ASNParserOF_LITERAL)
	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(877)
			p.AsnType()
		}

	case 2:
		{
			p.SetState(878)
			p.NamedType()
		}

	}

	return localctx
}

// IReferencedTypeContext is an interface to support dynamic dispatch.
type IReferencedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferencedTypeContext differentiates from other interfaces.
	IsReferencedTypeContext()
}

type ReferencedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferencedTypeContext() *ReferencedTypeContext {
	var p = new(ReferencedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_referencedType
	return p
}

func (*ReferencedTypeContext) IsReferencedTypeContext() {}

func NewReferencedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferencedTypeContext {
	var p = new(ReferencedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_referencedType

	return p
}

func (s *ReferencedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferencedTypeContext) DefinedType() IDefinedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedTypeContext)
}

func (s *ReferencedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferencedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferencedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterReferencedType(s)
	}
}

func (s *ReferencedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitReferencedType(s)
	}
}

func (s *ReferencedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitReferencedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ReferencedType() (localctx IReferencedTypeContext) {
	localctx = NewReferencedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ASNParserRULE_referencedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.DefinedType()
	}

	return localctx
}

// IDefinedTypeContext is an interface to support dynamic dispatch.
type IDefinedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedTypeContext differentiates from other interfaces.
	IsDefinedTypeContext()
}

type DefinedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedTypeContext() *DefinedTypeContext {
	var p = new(DefinedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_definedType
	return p
}

func (*DefinedTypeContext) IsDefinedTypeContext() {}

func NewDefinedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedTypeContext {
	var p = new(DefinedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_definedType

	return p
}

func (s *DefinedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedTypeContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *DefinedTypeContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *DefinedTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *DefinedTypeContext) ActualParameterList() IActualParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualParameterListContext)
}

func (s *DefinedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterDefinedType(s)
	}
}

func (s *DefinedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitDefinedType(s)
	}
}

func (s *DefinedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitDefinedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) DefinedType() (localctx IDefinedTypeContext) {
	localctx = NewDefinedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ASNParserRULE_definedType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(883)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserDOT {
		{
			p.SetState(884)
			p.Match(ASNParserDOT)
		}
		{
			p.SetState(885)
			p.Match(ASNParserIDENTIFIER)
		}

	}
	p.SetState(889)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(888)
			p.ActualParameterList()
		}

	}

	return localctx
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_constraint
	return p
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, 0)
}

func (s *ConstraintContext) ConstraintSpec() IConstraintSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintSpecContext)
}

func (s *ConstraintContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, 0)
}

func (s *ConstraintContext) ExceptionSpec() IExceptionSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecContext)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterConstraint(s)
	}
}

func (s *ConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitConstraint(s)
	}
}

func (s *ConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Constraint() (localctx IConstraintContext) {
	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ASNParserRULE_constraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(891)
		p.Match(ASNParserL_PARAN)
	}
	{
		p.SetState(892)
		p.ConstraintSpec()
	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserEXCLAM {
		{
			p.SetState(893)
			p.ExceptionSpec()
		}

	}
	{
		p.SetState(896)
		p.Match(ASNParserR_PARAN)
	}

	return localctx
}

// IConstraintSpecContext is an interface to support dynamic dispatch.
type IConstraintSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintSpecContext differentiates from other interfaces.
	IsConstraintSpecContext()
}

type ConstraintSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintSpecContext() *ConstraintSpecContext {
	var p = new(ConstraintSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_constraintSpec
	return p
}

func (*ConstraintSpecContext) IsConstraintSpecContext() {}

func NewConstraintSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintSpecContext {
	var p = new(ConstraintSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_constraintSpec

	return p
}

func (s *ConstraintSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintSpecContext) GeneralConstraint() IGeneralConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneralConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneralConstraintContext)
}

func (s *ConstraintSpecContext) SubtypeConstraint() ISubtypeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtypeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtypeConstraintContext)
}

func (s *ConstraintSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterConstraintSpec(s)
	}
}

func (s *ConstraintSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitConstraintSpec(s)
	}
}

func (s *ConstraintSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitConstraintSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ConstraintSpec() (localctx IConstraintSpecContext) {
	localctx = NewConstraintSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ASNParserRULE_constraintSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(898)
			p.GeneralConstraint()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(899)
			p.SubtypeConstraint()
		}

	}

	return localctx
}

// IUserDefinedConstraintContext is an interface to support dynamic dispatch.
type IUserDefinedConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserDefinedConstraintContext differentiates from other interfaces.
	IsUserDefinedConstraintContext()
}

type UserDefinedConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinedConstraintContext() *UserDefinedConstraintContext {
	var p = new(UserDefinedConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_userDefinedConstraint
	return p
}

func (*UserDefinedConstraintContext) IsUserDefinedConstraintContext() {}

func NewUserDefinedConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinedConstraintContext {
	var p = new(UserDefinedConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_userDefinedConstraint

	return p
}

func (s *UserDefinedConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinedConstraintContext) CONSTRAINED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCONSTRAINED_LITERAL, 0)
}

func (s *UserDefinedConstraintContext) BY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserBY_LITERAL, 0)
}

func (s *UserDefinedConstraintContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *UserDefinedConstraintContext) AllUserDefinedConstraintParameter() []IUserDefinedConstraintParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUserDefinedConstraintParameterContext)(nil)).Elem())
	var tst = make([]IUserDefinedConstraintParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUserDefinedConstraintParameterContext)
		}
	}

	return tst
}

func (s *UserDefinedConstraintContext) UserDefinedConstraintParameter(i int) IUserDefinedConstraintParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserDefinedConstraintParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUserDefinedConstraintParameterContext)
}

func (s *UserDefinedConstraintContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *UserDefinedConstraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *UserDefinedConstraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *UserDefinedConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinedConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinedConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterUserDefinedConstraint(s)
	}
}

func (s *UserDefinedConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitUserDefinedConstraint(s)
	}
}

func (s *UserDefinedConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitUserDefinedConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) UserDefinedConstraint() (localctx IUserDefinedConstraintContext) {
	localctx = NewUserDefinedConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ASNParserRULE_userDefinedConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.Match(ASNParserCONSTRAINED_LITERAL)
	}
	{
		p.SetState(903)
		p.Match(ASNParserBY_LITERAL)
	}
	{
		p.SetState(904)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(905)
		p.UserDefinedConstraintParameter()
	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(906)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(907)
			p.UserDefinedConstraintParameter()
		}

		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(913)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IGeneralConstraintContext is an interface to support dynamic dispatch.
type IGeneralConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneralConstraintContext differentiates from other interfaces.
	IsGeneralConstraintContext()
}

type GeneralConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralConstraintContext() *GeneralConstraintContext {
	var p = new(GeneralConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_generalConstraint
	return p
}

func (*GeneralConstraintContext) IsGeneralConstraintContext() {}

func NewGeneralConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralConstraintContext {
	var p = new(GeneralConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_generalConstraint

	return p
}

func (s *GeneralConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralConstraintContext) UserDefinedConstraint() IUserDefinedConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserDefinedConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserDefinedConstraintContext)
}

func (s *GeneralConstraintContext) TableConstraint() ITableConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *GeneralConstraintContext) ContentsConstraint() IContentsConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContentsConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContentsConstraintContext)
}

func (s *GeneralConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterGeneralConstraint(s)
	}
}

func (s *GeneralConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitGeneralConstraint(s)
	}
}

func (s *GeneralConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitGeneralConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) GeneralConstraint() (localctx IGeneralConstraintContext) {
	localctx = NewGeneralConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ASNParserRULE_generalConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(918)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserCONSTRAINED_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(915)
			p.UserDefinedConstraint()
		}

	case ASNParserL_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(916)
			p.TableConstraint()
		}

	case ASNParserCONTAINING_LITERAL, ASNParserENCODED_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(917)
			p.ContentsConstraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUserDefinedConstraintParameterContext is an interface to support dynamic dispatch.
type IUserDefinedConstraintParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserDefinedConstraintParameterContext differentiates from other interfaces.
	IsUserDefinedConstraintParameterContext()
}

type UserDefinedConstraintParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinedConstraintParameterContext() *UserDefinedConstraintParameterContext {
	var p = new(UserDefinedConstraintParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_userDefinedConstraintParameter
	return p
}

func (*UserDefinedConstraintParameterContext) IsUserDefinedConstraintParameterContext() {}

func NewUserDefinedConstraintParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinedConstraintParameterContext {
	var p = new(UserDefinedConstraintParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_userDefinedConstraintParameter

	return p
}

func (s *UserDefinedConstraintParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinedConstraintParameterContext) Governor() IGovernorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGovernorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGovernorContext)
}

func (s *UserDefinedConstraintParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserCOLON, 0)
}

func (s *UserDefinedConstraintParameterContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *UserDefinedConstraintParameterContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *UserDefinedConstraintParameterContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *UserDefinedConstraintParameterContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *UserDefinedConstraintParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinedConstraintParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinedConstraintParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterUserDefinedConstraintParameter(s)
	}
}

func (s *UserDefinedConstraintParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitUserDefinedConstraintParameter(s)
	}
}

func (s *UserDefinedConstraintParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitUserDefinedConstraintParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) UserDefinedConstraintParameter() (localctx IUserDefinedConstraintParameterContext) {
	localctx = NewUserDefinedConstraintParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ASNParserRULE_userDefinedConstraintParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(920)
		p.Governor()
	}
	p.SetState(926)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(921)
			p.Match(ASNParserCOLON)
		}
		{
			p.SetState(922)
			p.Value()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(923)
			p.ValueSet()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(924)
			p.Object()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(925)
			p.ObjectSet()
		}

	}

	return localctx
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_tableConstraint
	return p
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) ComponentRelationConstraint() IComponentRelationConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentRelationConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentRelationConstraintContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterTableConstraint(s)
	}
}

func (s *TableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitTableConstraint(s)
	}
}

func (s *TableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ASNParserRULE_tableConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.ComponentRelationConstraint()
	}

	return localctx
}

// ISimpleTableConstraintContext is an interface to support dynamic dispatch.
type ISimpleTableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleTableConstraintContext differentiates from other interfaces.
	IsSimpleTableConstraintContext()
}

type SimpleTableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTableConstraintContext() *SimpleTableConstraintContext {
	var p = new(SimpleTableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_simpleTableConstraint
	return p
}

func (*SimpleTableConstraintContext) IsSimpleTableConstraintContext() {}

func NewSimpleTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTableConstraintContext {
	var p = new(SimpleTableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_simpleTableConstraint

	return p
}

func (s *SimpleTableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTableConstraintContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *SimpleTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSimpleTableConstraint(s)
	}
}

func (s *SimpleTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSimpleTableConstraint(s)
	}
}

func (s *SimpleTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSimpleTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SimpleTableConstraint() (localctx ISimpleTableConstraintContext) {
	localctx = NewSimpleTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ASNParserRULE_simpleTableConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.ObjectSet()
	}

	return localctx
}

// IContentsConstraintContext is an interface to support dynamic dispatch.
type IContentsConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContentsConstraintContext differentiates from other interfaces.
	IsContentsConstraintContext()
}

type ContentsConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContentsConstraintContext() *ContentsConstraintContext {
	var p = new(ContentsConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_contentsConstraint
	return p
}

func (*ContentsConstraintContext) IsContentsConstraintContext() {}

func NewContentsConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContentsConstraintContext {
	var p = new(ContentsConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_contentsConstraint

	return p
}

func (s *ContentsConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ContentsConstraintContext) CONTAINING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCONTAINING_LITERAL, 0)
}

func (s *ContentsConstraintContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ContentsConstraintContext) ENCODED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserENCODED_LITERAL, 0)
}

func (s *ContentsConstraintContext) BY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserBY_LITERAL, 0)
}

func (s *ContentsConstraintContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ContentsConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContentsConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContentsConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterContentsConstraint(s)
	}
}

func (s *ContentsConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitContentsConstraint(s)
	}
}

func (s *ContentsConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitContentsConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ContentsConstraint() (localctx IContentsConstraintContext) {
	localctx = NewContentsConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ASNParserRULE_contentsConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)
			p.Match(ASNParserCONTAINING_LITERAL)
		}
		{
			p.SetState(933)
			p.AsnType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(934)
			p.Match(ASNParserENCODED_LITERAL)
		}
		{
			p.SetState(935)
			p.Match(ASNParserBY_LITERAL)
		}
		{
			p.SetState(936)
			p.Value()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(937)
			p.Match(ASNParserCONTAINING_LITERAL)
		}
		{
			p.SetState(938)
			p.AsnType()
		}
		{
			p.SetState(939)
			p.Match(ASNParserENCODED_LITERAL)
		}
		{
			p.SetState(940)
			p.Match(ASNParserBY_LITERAL)
		}
		{
			p.SetState(941)
			p.Value()
		}

	}

	return localctx
}

// ISubtypeConstraintContext is an interface to support dynamic dispatch.
type ISubtypeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtypeConstraintContext differentiates from other interfaces.
	IsSubtypeConstraintContext()
}

type SubtypeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtypeConstraintContext() *SubtypeConstraintContext {
	var p = new(SubtypeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_subtypeConstraint
	return p
}

func (*SubtypeConstraintContext) IsSubtypeConstraintContext() {}

func NewSubtypeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtypeConstraintContext {
	var p = new(SubtypeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_subtypeConstraint

	return p
}

func (s *SubtypeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtypeConstraintContext) ElementSetSpecs() IElementSetSpecsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecsContext)
}

func (s *SubtypeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtypeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtypeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSubtypeConstraint(s)
	}
}

func (s *SubtypeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSubtypeConstraint(s)
	}
}

func (s *SubtypeConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSubtypeConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SubtypeConstraint() (localctx ISubtypeConstraintContext) {
	localctx = NewSubtypeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ASNParserRULE_subtypeConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(945)
		p.ElementSetSpecs()
	}

	return localctx
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_value
	return p
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) BuiltinValue() IBuiltinValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBuiltinValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBuiltinValueContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitValue(s)
	}
}

func (s *ValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ASNParserRULE_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(947)
		p.BuiltinValue()
	}

	return localctx
}

// IBuiltinValueContext is an interface to support dynamic dispatch.
type IBuiltinValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBuiltinValueContext differentiates from other interfaces.
	IsBuiltinValueContext()
}

type BuiltinValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltinValueContext() *BuiltinValueContext {
	var p = new(BuiltinValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_builtinValue
	return p
}

func (*BuiltinValueContext) IsBuiltinValueContext() {}

func NewBuiltinValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltinValueContext {
	var p = new(BuiltinValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_builtinValue

	return p
}

func (s *BuiltinValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltinValueContext) EnumeratedValue() IEnumeratedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratedValueContext)
}

func (s *BuiltinValueContext) IntegerValue() IIntegerValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerValueContext)
}

func (s *BuiltinValueContext) ChoiceValue() IChoiceValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoiceValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoiceValueContext)
}

func (s *BuiltinValueContext) ObjectIdentifierValue() IObjectIdentifierValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectIdentifierValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifierValueContext)
}

func (s *BuiltinValueContext) BooleanValue() IBooleanValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BuiltinValueContext) CSTRING() antlr.TerminalNode {
	return s.GetToken(ASNParserCSTRING, 0)
}

func (s *BuiltinValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltinValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltinValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterBuiltinValue(s)
	}
}

func (s *BuiltinValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitBuiltinValue(s)
	}
}

func (s *BuiltinValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitBuiltinValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) BuiltinValue() (localctx IBuiltinValueContext) {
	localctx = NewBuiltinValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ASNParserRULE_builtinValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(949)
			p.EnumeratedValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(950)
			p.IntegerValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(951)
			p.ChoiceValue()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(952)
			p.ObjectIdentifierValue()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(953)
			p.BooleanValue()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(954)
			p.Match(ASNParserCSTRING)
		}

	}

	return localctx
}

// IObjectIdentifierValueContext is an interface to support dynamic dispatch.
type IObjectIdentifierValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectIdentifierValueContext differentiates from other interfaces.
	IsObjectIdentifierValueContext()
}

type ObjectIdentifierValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectIdentifierValueContext() *ObjectIdentifierValueContext {
	var p = new(ObjectIdentifierValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectIdentifierValue
	return p
}

func (*ObjectIdentifierValueContext) IsObjectIdentifierValueContext() {}

func NewObjectIdentifierValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectIdentifierValueContext {
	var p = new(ObjectIdentifierValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectIdentifierValue

	return p
}

func (s *ObjectIdentifierValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectIdentifierValueContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ObjectIdentifierValueContext) ObjIdComponentsList() IObjIdComponentsListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjIdComponentsListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjIdComponentsListContext)
}

func (s *ObjectIdentifierValueContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ObjectIdentifierValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectIdentifierValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectIdentifierValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectIdentifierValue(s)
	}
}

func (s *ObjectIdentifierValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectIdentifierValue(s)
	}
}

func (s *ObjectIdentifierValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectIdentifierValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjectIdentifierValue() (localctx IObjectIdentifierValueContext) {
	localctx = NewObjectIdentifierValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ASNParserRULE_objectIdentifierValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(957)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(958)
		p.ObjIdComponentsList()
	}
	{
		p.SetState(959)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IObjIdComponentsListContext is an interface to support dynamic dispatch.
type IObjIdComponentsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjIdComponentsListContext differentiates from other interfaces.
	IsObjIdComponentsListContext()
}

type ObjIdComponentsListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjIdComponentsListContext() *ObjIdComponentsListContext {
	var p = new(ObjIdComponentsListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objIdComponentsList
	return p
}

func (*ObjIdComponentsListContext) IsObjIdComponentsListContext() {}

func NewObjIdComponentsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjIdComponentsListContext {
	var p = new(ObjIdComponentsListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objIdComponentsList

	return p
}

func (s *ObjIdComponentsListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjIdComponentsListContext) AllObjIdComponents() []IObjIdComponentsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObjIdComponentsContext)(nil)).Elem())
	var tst = make([]IObjIdComponentsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObjIdComponentsContext)
		}
	}

	return tst
}

func (s *ObjIdComponentsListContext) ObjIdComponents(i int) IObjIdComponentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjIdComponentsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObjIdComponentsContext)
}

func (s *ObjIdComponentsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjIdComponentsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjIdComponentsListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjIdComponentsList(s)
	}
}

func (s *ObjIdComponentsListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjIdComponentsList(s)
	}
}

func (s *ObjIdComponentsListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjIdComponentsList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjIdComponentsList() (localctx IObjIdComponentsListContext) {
	localctx = NewObjIdComponentsListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ASNParserRULE_objIdComponentsList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(961)
		p.ObjIdComponents()
	}

	p.SetState(965)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserNUMBER || _la == ASNParserIDENTIFIER {
		{
			p.SetState(962)
			p.ObjIdComponents()
		}

		p.SetState(967)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObjIdComponentsContext is an interface to support dynamic dispatch.
type IObjIdComponentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjIdComponentsContext differentiates from other interfaces.
	IsObjIdComponentsContext()
}

type ObjIdComponentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjIdComponentsContext() *ObjIdComponentsContext {
	var p = new(ObjIdComponentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objIdComponents
	return p
}

func (*ObjIdComponentsContext) IsObjIdComponentsContext() {}

func NewObjIdComponentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjIdComponentsContext {
	var p = new(ObjIdComponentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objIdComponents

	return p
}

func (s *ObjIdComponentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjIdComponentsContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASNParserNUMBER, 0)
}

func (s *ObjIdComponentsContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ObjIdComponentsContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, 0)
}

func (s *ObjIdComponentsContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, 0)
}

func (s *ObjIdComponentsContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *ObjIdComponentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjIdComponentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjIdComponentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjIdComponents(s)
	}
}

func (s *ObjIdComponentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjIdComponents(s)
	}
}

func (s *ObjIdComponentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjIdComponents(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ObjIdComponents() (localctx IObjIdComponentsContext) {
	localctx = NewObjIdComponentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ASNParserRULE_objIdComponents)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(968)
			p.Match(ASNParserNUMBER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(969)
			p.Match(ASNParserIDENTIFIER)
		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserL_PARAN {
			{
				p.SetState(970)
				p.Match(ASNParserL_PARAN)
			}
			p.SetState(973)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ASNParserNUMBER:
				{
					p.SetState(971)
					p.Match(ASNParserNUMBER)
				}

			case ASNParserIDENTIFIER:
				{
					p.SetState(972)
					p.DefinedValue()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(975)
				p.Match(ASNParserR_PARAN)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(978)
			p.DefinedValue()
		}

	}

	return localctx
}

// IIntegerValueContext is an interface to support dynamic dispatch.
type IIntegerValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerValueContext differentiates from other interfaces.
	IsIntegerValueContext()
}

type IntegerValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerValueContext() *IntegerValueContext {
	var p = new(IntegerValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_integerValue
	return p
}

func (*IntegerValueContext) IsIntegerValueContext() {}

func NewIntegerValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerValueContext {
	var p = new(IntegerValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_integerValue

	return p
}

func (s *IntegerValueContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerValueContext) SignedNumber() ISignedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *IntegerValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *IntegerValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterIntegerValue(s)
	}
}

func (s *IntegerValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitIntegerValue(s)
	}
}

func (s *IntegerValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitIntegerValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) IntegerValue() (localctx IIntegerValueContext) {
	localctx = NewIntegerValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ASNParserRULE_integerValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(983)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserMINUS, ASNParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(981)
			p.SignedNumber()
		}

	case ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(982)
			p.Match(ASNParserIDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChoiceValueContext is an interface to support dynamic dispatch.
type IChoiceValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoiceValueContext differentiates from other interfaces.
	IsChoiceValueContext()
}

type ChoiceValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoiceValueContext() *ChoiceValueContext {
	var p = new(ChoiceValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_choiceValue
	return p
}

func (*ChoiceValueContext) IsChoiceValueContext() {}

func NewChoiceValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoiceValueContext {
	var p = new(ChoiceValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_choiceValue

	return p
}

func (s *ChoiceValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoiceValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *ChoiceValueContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserCOLON, 0)
}

func (s *ChoiceValueContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ChoiceValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoiceValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoiceValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterChoiceValue(s)
	}
}

func (s *ChoiceValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitChoiceValue(s)
	}
}

func (s *ChoiceValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitChoiceValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ChoiceValue() (localctx IChoiceValueContext) {
	localctx = NewChoiceValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ASNParserRULE_choiceValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(985)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(986)
		p.Match(ASNParserCOLON)
	}
	{
		p.SetState(987)
		p.Value()
	}

	return localctx
}

// IEnumeratedValueContext is an interface to support dynamic dispatch.
type IEnumeratedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratedValueContext differentiates from other interfaces.
	IsEnumeratedValueContext()
}

type EnumeratedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratedValueContext() *EnumeratedValueContext {
	var p = new(EnumeratedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_enumeratedValue
	return p
}

func (*EnumeratedValueContext) IsEnumeratedValueContext() {}

func NewEnumeratedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratedValueContext {
	var p = new(EnumeratedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_enumeratedValue

	return p
}

func (s *EnumeratedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratedValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *EnumeratedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterEnumeratedValue(s)
	}
}

func (s *EnumeratedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitEnumeratedValue(s)
	}
}

func (s *EnumeratedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitEnumeratedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) EnumeratedValue() (localctx IEnumeratedValueContext) {
	localctx = NewEnumeratedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ASNParserRULE_enumeratedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(989)
		p.Match(ASNParserIDENTIFIER)
	}

	return localctx
}

// ISignedNumberContext is an interface to support dynamic dispatch.
type ISignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignedNumberContext differentiates from other interfaces.
	IsSignedNumberContext()
}

type SignedNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedNumberContext() *SignedNumberContext {
	var p = new(SignedNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_signedNumber
	return p
}

func (*SignedNumberContext) IsSignedNumberContext() {}

func NewSignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedNumberContext {
	var p = new(SignedNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_signedNumber

	return p
}

func (s *SignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASNParserNUMBER, 0)
}

func (s *SignedNumberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ASNParserMINUS, 0)
}

func (s *SignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSignedNumber(s)
	}
}

func (s *SignedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSignedNumber(s)
	}
}

func (s *SignedNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSignedNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SignedNumber() (localctx ISignedNumberContext) {
	localctx = NewSignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ASNParserRULE_signedNumber)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(992)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserMINUS {
		{
			p.SetState(991)
			p.Match(ASNParserMINUS)
		}

	}
	{
		p.SetState(994)
		p.Match(ASNParserNUMBER)
	}

	return localctx
}

// IChoiceTypeContext is an interface to support dynamic dispatch.
type IChoiceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoiceTypeContext differentiates from other interfaces.
	IsChoiceTypeContext()
}

type ChoiceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoiceTypeContext() *ChoiceTypeContext {
	var p = new(ChoiceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_choiceType
	return p
}

func (*ChoiceTypeContext) IsChoiceTypeContext() {}

func NewChoiceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoiceTypeContext {
	var p = new(ChoiceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_choiceType

	return p
}

func (s *ChoiceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoiceTypeContext) CHOICE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserCHOICE_LITERAL, 0)
}

func (s *ChoiceTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ChoiceTypeContext) AlternativeTypeLists() IAlternativeTypeListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternativeTypeListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternativeTypeListsContext)
}

func (s *ChoiceTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ChoiceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoiceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoiceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterChoiceType(s)
	}
}

func (s *ChoiceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitChoiceType(s)
	}
}

func (s *ChoiceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitChoiceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ChoiceType() (localctx IChoiceTypeContext) {
	localctx = NewChoiceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ASNParserRULE_choiceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(996)
		p.Match(ASNParserCHOICE_LITERAL)
	}
	{
		p.SetState(997)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(998)
		p.AlternativeTypeLists()
	}
	{
		p.SetState(999)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IAlternativeTypeListsContext is an interface to support dynamic dispatch.
type IAlternativeTypeListsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternativeTypeListsContext differentiates from other interfaces.
	IsAlternativeTypeListsContext()
}

type AlternativeTypeListsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternativeTypeListsContext() *AlternativeTypeListsContext {
	var p = new(AlternativeTypeListsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_alternativeTypeLists
	return p
}

func (*AlternativeTypeListsContext) IsAlternativeTypeListsContext() {}

func NewAlternativeTypeListsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternativeTypeListsContext {
	var p = new(AlternativeTypeListsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_alternativeTypeLists

	return p
}

func (s *AlternativeTypeListsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternativeTypeListsContext) RootAlternativeTypeList() IRootAlternativeTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootAlternativeTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootAlternativeTypeListContext)
}

func (s *AlternativeTypeListsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, 0)
}

func (s *AlternativeTypeListsContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *AlternativeTypeListsContext) ExtensionAdditionAlternatives() IExtensionAdditionAlternativesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativesContext)
}

func (s *AlternativeTypeListsContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *AlternativeTypeListsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternativeTypeListsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternativeTypeListsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAlternativeTypeLists(s)
	}
}

func (s *AlternativeTypeListsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAlternativeTypeLists(s)
	}
}

func (s *AlternativeTypeListsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitAlternativeTypeLists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) AlternativeTypeLists() (localctx IAlternativeTypeListsContext) {
	localctx = NewAlternativeTypeListsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ASNParserRULE_alternativeTypeLists)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1001)
		p.RootAlternativeTypeList()
	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserCOMMA {
		{
			p.SetState(1002)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1003)
			p.ExtensionAndException()
		}
		{
			p.SetState(1004)
			p.ExtensionAdditionAlternatives()
		}
		{
			p.SetState(1005)
			p.OptionalExtensionMarker()
		}

	}

	return localctx
}

// IExtensionAdditionAlternativesContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativesContext differentiates from other interfaces.
	IsExtensionAdditionAlternativesContext()
}

type ExtensionAdditionAlternativesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativesContext() *ExtensionAdditionAlternativesContext {
	var p = new(ExtensionAdditionAlternativesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternatives
	return p
}

func (*ExtensionAdditionAlternativesContext) IsExtensionAdditionAlternativesContext() {}

func NewExtensionAdditionAlternativesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativesContext {
	var p = new(ExtensionAdditionAlternativesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternatives

	return p
}

func (s *ExtensionAdditionAlternativesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativesContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, 0)
}

func (s *ExtensionAdditionAlternativesContext) ExtensionAdditionAlternativesList() IExtensionAdditionAlternativesListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativesListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativesListContext)
}

func (s *ExtensionAdditionAlternativesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionAlternatives(s)
	}
}

func (s *ExtensionAdditionAlternativesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionAlternatives(s)
	}
}

func (s *ExtensionAdditionAlternativesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExtensionAdditionAlternatives(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExtensionAdditionAlternatives() (localctx IExtensionAdditionAlternativesContext) {
	localctx = NewExtensionAdditionAlternativesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ASNParserRULE_extensionAdditionAlternatives)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1011)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1009)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1010)
			p.ExtensionAdditionAlternativesList()
		}

	}

	return localctx
}

// IExtensionAdditionAlternativesListContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativesListContext differentiates from other interfaces.
	IsExtensionAdditionAlternativesListContext()
}

type ExtensionAdditionAlternativesListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativesListContext() *ExtensionAdditionAlternativesListContext {
	var p = new(ExtensionAdditionAlternativesListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternativesList
	return p
}

func (*ExtensionAdditionAlternativesListContext) IsExtensionAdditionAlternativesListContext() {}

func NewExtensionAdditionAlternativesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativesListContext {
	var p = new(ExtensionAdditionAlternativesListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternativesList

	return p
}

func (s *ExtensionAdditionAlternativesListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativesListContext) AllExtensionAdditionAlternative() []IExtensionAdditionAlternativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExtensionAdditionAlternativeContext)(nil)).Elem())
	var tst = make([]IExtensionAdditionAlternativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExtensionAdditionAlternativeContext)
		}
	}

	return tst
}

func (s *ExtensionAdditionAlternativesListContext) ExtensionAdditionAlternative(i int) IExtensionAdditionAlternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativeContext)
}

func (s *ExtensionAdditionAlternativesListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ExtensionAdditionAlternativesListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ExtensionAdditionAlternativesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionAlternativesList(s)
	}
}

func (s *ExtensionAdditionAlternativesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionAlternativesList(s)
	}
}

func (s *ExtensionAdditionAlternativesListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExtensionAdditionAlternativesList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExtensionAdditionAlternativesList() (localctx IExtensionAdditionAlternativesListContext) {
	localctx = NewExtensionAdditionAlternativesListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ASNParserRULE_extensionAdditionAlternativesList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.ExtensionAdditionAlternative()
	}

	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1014)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(1015)
				p.ExtensionAdditionAlternative()
			}

		}
		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())
	}

	return localctx
}

// IExtensionAdditionAlternativeContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativeContext differentiates from other interfaces.
	IsExtensionAdditionAlternativeContext()
}

type ExtensionAdditionAlternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativeContext() *ExtensionAdditionAlternativeContext {
	var p = new(ExtensionAdditionAlternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternative
	return p
}

func (*ExtensionAdditionAlternativeContext) IsExtensionAdditionAlternativeContext() {}

func NewExtensionAdditionAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativeContext {
	var p = new(ExtensionAdditionAlternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternative

	return p
}

func (s *ExtensionAdditionAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativeContext) ExtensionAdditionAlternativesGroup() IExtensionAdditionAlternativesGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativesGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativesGroupContext)
}

func (s *ExtensionAdditionAlternativeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *ExtensionAdditionAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionAlternative(s)
	}
}

func (s *ExtensionAdditionAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionAlternative(s)
	}
}

func (s *ExtensionAdditionAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExtensionAdditionAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExtensionAdditionAlternative() (localctx IExtensionAdditionAlternativeContext) {
	localctx = NewExtensionAdditionAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ASNParserRULE_extensionAdditionAlternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1023)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserDOUBLE_L_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1021)
			p.ExtensionAdditionAlternativesGroup()
		}

	case ASNParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.NamedType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtensionAdditionAlternativesGroupContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativesGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativesGroupContext differentiates from other interfaces.
	IsExtensionAdditionAlternativesGroupContext()
}

type ExtensionAdditionAlternativesGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativesGroupContext() *ExtensionAdditionAlternativesGroupContext {
	var p = new(ExtensionAdditionAlternativesGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternativesGroup
	return p
}

func (*ExtensionAdditionAlternativesGroupContext) IsExtensionAdditionAlternativesGroupContext() {}

func NewExtensionAdditionAlternativesGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativesGroupContext {
	var p = new(ExtensionAdditionAlternativesGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_extensionAdditionAlternativesGroup

	return p
}

func (s *ExtensionAdditionAlternativesGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativesGroupContext) DOUBLE_L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserDOUBLE_L_BRACKET, 0)
}

func (s *ExtensionAdditionAlternativesGroupContext) VersionNumber() IVersionNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVersionNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVersionNumberContext)
}

func (s *ExtensionAdditionAlternativesGroupContext) AlternativeTypeList() IAlternativeTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternativeTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternativeTypeListContext)
}

func (s *ExtensionAdditionAlternativesGroupContext) DOUBLE_R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASNParserDOUBLE_R_BRACKET, 0)
}

func (s *ExtensionAdditionAlternativesGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativesGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativesGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExtensionAdditionAlternativesGroup(s)
	}
}

func (s *ExtensionAdditionAlternativesGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExtensionAdditionAlternativesGroup(s)
	}
}

func (s *ExtensionAdditionAlternativesGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExtensionAdditionAlternativesGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExtensionAdditionAlternativesGroup() (localctx IExtensionAdditionAlternativesGroupContext) {
	localctx = NewExtensionAdditionAlternativesGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, ASNParserRULE_extensionAdditionAlternativesGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1025)
		p.Match(ASNParserDOUBLE_L_BRACKET)
	}
	{
		p.SetState(1026)
		p.VersionNumber()
	}
	{
		p.SetState(1027)
		p.AlternativeTypeList()
	}
	{
		p.SetState(1028)
		p.Match(ASNParserDOUBLE_R_BRACKET)
	}

	return localctx
}

// IRootAlternativeTypeListContext is an interface to support dynamic dispatch.
type IRootAlternativeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootAlternativeTypeListContext differentiates from other interfaces.
	IsRootAlternativeTypeListContext()
}

type RootAlternativeTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootAlternativeTypeListContext() *RootAlternativeTypeListContext {
	var p = new(RootAlternativeTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_rootAlternativeTypeList
	return p
}

func (*RootAlternativeTypeListContext) IsRootAlternativeTypeListContext() {}

func NewRootAlternativeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootAlternativeTypeListContext {
	var p = new(RootAlternativeTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_rootAlternativeTypeList

	return p
}

func (s *RootAlternativeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *RootAlternativeTypeListContext) AlternativeTypeList() IAlternativeTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternativeTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternativeTypeListContext)
}

func (s *RootAlternativeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootAlternativeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootAlternativeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterRootAlternativeTypeList(s)
	}
}

func (s *RootAlternativeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitRootAlternativeTypeList(s)
	}
}

func (s *RootAlternativeTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitRootAlternativeTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) RootAlternativeTypeList() (localctx IRootAlternativeTypeListContext) {
	localctx = NewRootAlternativeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, ASNParserRULE_rootAlternativeTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1030)
		p.AlternativeTypeList()
	}

	return localctx
}

// IAlternativeTypeListContext is an interface to support dynamic dispatch.
type IAlternativeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternativeTypeListContext differentiates from other interfaces.
	IsAlternativeTypeListContext()
}

type AlternativeTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternativeTypeListContext() *AlternativeTypeListContext {
	var p = new(AlternativeTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_alternativeTypeList
	return p
}

func (*AlternativeTypeListContext) IsAlternativeTypeListContext() {}

func NewAlternativeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternativeTypeListContext {
	var p = new(AlternativeTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_alternativeTypeList

	return p
}

func (s *AlternativeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternativeTypeListContext) AllNamedType() []INamedTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedTypeContext)(nil)).Elem())
	var tst = make([]INamedTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedTypeContext)
		}
	}

	return tst
}

func (s *AlternativeTypeListContext) NamedType(i int) INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *AlternativeTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *AlternativeTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *AlternativeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternativeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternativeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAlternativeTypeList(s)
	}
}

func (s *AlternativeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAlternativeTypeList(s)
	}
}

func (s *AlternativeTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitAlternativeTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) AlternativeTypeList() (localctx IAlternativeTypeListContext) {
	localctx = NewAlternativeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, ASNParserRULE_alternativeTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1032)
		p.NamedType()
	}

	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1033)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(1034)
				p.NamedType()
			}

		}
		p.SetState(1039)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())
	}

	return localctx
}

// INamedTypeContext is an interface to support dynamic dispatch.
type INamedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedTypeContext differentiates from other interfaces.
	IsNamedTypeContext()
}

type NamedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedTypeContext() *NamedTypeContext {
	var p = new(NamedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_namedType
	return p
}

func (*NamedTypeContext) IsNamedTypeContext() {}

func NewNamedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedTypeContext {
	var p = new(NamedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_namedType

	return p
}

func (s *NamedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedTypeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *NamedTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *NamedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterNamedType(s)
	}
}

func (s *NamedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitNamedType(s)
	}
}

func (s *NamedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitNamedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) NamedType() (localctx INamedTypeContext) {
	localctx = NewNamedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, ASNParserRULE_namedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(1041)
		p.AsnType()
	}

	return localctx
}

// IEnumeratedTypeContext is an interface to support dynamic dispatch.
type IEnumeratedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratedTypeContext differentiates from other interfaces.
	IsEnumeratedTypeContext()
}

type EnumeratedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratedTypeContext() *EnumeratedTypeContext {
	var p = new(EnumeratedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_enumeratedType
	return p
}

func (*EnumeratedTypeContext) IsEnumeratedTypeContext() {}

func NewEnumeratedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratedTypeContext {
	var p = new(EnumeratedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_enumeratedType

	return p
}

func (s *EnumeratedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratedTypeContext) ENUMERATED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserENUMERATED_LITERAL, 0)
}

func (s *EnumeratedTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *EnumeratedTypeContext) Enumerations() IEnumerationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerationsContext)
}

func (s *EnumeratedTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *EnumeratedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterEnumeratedType(s)
	}
}

func (s *EnumeratedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitEnumeratedType(s)
	}
}

func (s *EnumeratedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitEnumeratedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) EnumeratedType() (localctx IEnumeratedTypeContext) {
	localctx = NewEnumeratedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, ASNParserRULE_enumeratedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1043)
		p.Match(ASNParserENUMERATED_LITERAL)
	}
	{
		p.SetState(1044)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(1045)
		p.Enumerations()
	}
	{
		p.SetState(1046)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IEnumerationsContext is an interface to support dynamic dispatch.
type IEnumerationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationsContext differentiates from other interfaces.
	IsEnumerationsContext()
}

type EnumerationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationsContext() *EnumerationsContext {
	var p = new(EnumerationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_enumerations
	return p
}

func (*EnumerationsContext) IsEnumerationsContext() {}

func NewEnumerationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationsContext {
	var p = new(EnumerationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_enumerations

	return p
}

func (s *EnumerationsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationsContext) RootEnumeration() IRootEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootEnumerationContext)
}

func (s *EnumerationsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *EnumerationsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *EnumerationsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASNParserELLIPSIS, 0)
}

func (s *EnumerationsContext) ExceptionSpec() IExceptionSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecContext)
}

func (s *EnumerationsContext) AdditionalEnumeration() IAdditionalEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditionalEnumerationContext)
}

func (s *EnumerationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterEnumerations(s)
	}
}

func (s *EnumerationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitEnumerations(s)
	}
}

func (s *EnumerationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitEnumerations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Enumerations() (localctx IEnumerationsContext) {
	localctx = NewEnumerationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, ASNParserRULE_enumerations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1048)
		p.RootEnumeration()
	}
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserCOMMA {
		{
			p.SetState(1049)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1050)
			p.Match(ASNParserELLIPSIS)
		}
		p.SetState(1052)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserEXCLAM {
			{
				p.SetState(1051)
				p.ExceptionSpec()
			}

		}
		p.SetState(1056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASNParserCOMMA {
			{
				p.SetState(1054)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(1055)
				p.AdditionalEnumeration()
			}

		}

	}

	return localctx
}

// IRootEnumerationContext is an interface to support dynamic dispatch.
type IRootEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootEnumerationContext differentiates from other interfaces.
	IsRootEnumerationContext()
}

type RootEnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootEnumerationContext() *RootEnumerationContext {
	var p = new(RootEnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_rootEnumeration
	return p
}

func (*RootEnumerationContext) IsRootEnumerationContext() {}

func NewRootEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootEnumerationContext {
	var p = new(RootEnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_rootEnumeration

	return p
}

func (s *RootEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *RootEnumerationContext) Enumeration() IEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerationContext)
}

func (s *RootEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterRootEnumeration(s)
	}
}

func (s *RootEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitRootEnumeration(s)
	}
}

func (s *RootEnumerationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitRootEnumeration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) RootEnumeration() (localctx IRootEnumerationContext) {
	localctx = NewRootEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, ASNParserRULE_rootEnumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1060)
		p.Enumeration()
	}

	return localctx
}

// IEnumerationContext is an interface to support dynamic dispatch.
type IEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationContext differentiates from other interfaces.
	IsEnumerationContext()
}

type EnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationContext() *EnumerationContext {
	var p = new(EnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_enumeration
	return p
}

func (*EnumerationContext) IsEnumerationContext() {}

func NewEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationContext {
	var p = new(EnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_enumeration

	return p
}

func (s *EnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationContext) AllEnumerationItem() []IEnumerationItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumerationItemContext)(nil)).Elem())
	var tst = make([]IEnumerationItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumerationItemContext)
		}
	}

	return tst
}

func (s *EnumerationContext) EnumerationItem(i int) IEnumerationItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumerationItemContext)
}

func (s *EnumerationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *EnumerationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *EnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterEnumeration(s)
	}
}

func (s *EnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitEnumeration(s)
	}
}

func (s *EnumerationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitEnumeration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Enumeration() (localctx IEnumerationContext) {
	localctx = NewEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, ASNParserRULE_enumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1062)
		p.EnumerationItem()
	}
	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1063)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(1064)
				p.EnumerationItem()
			}

		}
		p.SetState(1069)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumerationItemContext is an interface to support dynamic dispatch.
type IEnumerationItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationItemContext differentiates from other interfaces.
	IsEnumerationItemContext()
}

type EnumerationItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationItemContext() *EnumerationItemContext {
	var p = new(EnumerationItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_enumerationItem
	return p
}

func (*EnumerationItemContext) IsEnumerationItemContext() {}

func NewEnumerationItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationItemContext {
	var p = new(EnumerationItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_enumerationItem

	return p
}

func (s *EnumerationItemContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationItemContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *EnumerationItemContext) NamedNumber() INamedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedNumberContext)
}

func (s *EnumerationItemContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *EnumerationItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterEnumerationItem(s)
	}
}

func (s *EnumerationItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitEnumerationItem(s)
	}
}

func (s *EnumerationItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitEnumerationItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) EnumerationItem() (localctx IEnumerationItemContext) {
	localctx = NewEnumerationItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, ASNParserRULE_enumerationItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1073)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1070)
			p.Match(ASNParserIDENTIFIER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1071)
			p.NamedNumber()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1072)
			p.Value()
		}

	}

	return localctx
}

// INamedNumberContext is an interface to support dynamic dispatch.
type INamedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedNumberContext differentiates from other interfaces.
	IsNamedNumberContext()
}

type NamedNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedNumberContext() *NamedNumberContext {
	var p = new(NamedNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_namedNumber
	return p
}

func (*NamedNumberContext) IsNamedNumberContext() {}

func NewNamedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedNumberContext {
	var p = new(NamedNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_namedNumber

	return p
}

func (s *NamedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedNumberContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *NamedNumberContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, 0)
}

func (s *NamedNumberContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, 0)
}

func (s *NamedNumberContext) SignedNumber() ISignedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *NamedNumberContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *NamedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterNamedNumber(s)
	}
}

func (s *NamedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitNamedNumber(s)
	}
}

func (s *NamedNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitNamedNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) NamedNumber() (localctx INamedNumberContext) {
	localctx = NewNamedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, ASNParserRULE_namedNumber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1075)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(1076)
		p.Match(ASNParserL_PARAN)
	}
	p.SetState(1079)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserMINUS, ASNParserNUMBER:
		{
			p.SetState(1077)
			p.SignedNumber()
		}

	case ASNParserIDENTIFIER:
		{
			p.SetState(1078)
			p.DefinedValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1081)
		p.Match(ASNParserR_PARAN)
	}

	return localctx
}

// IDefinedValueContext is an interface to support dynamic dispatch.
type IDefinedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedValueContext differentiates from other interfaces.
	IsDefinedValueContext()
}

type DefinedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedValueContext() *DefinedValueContext {
	var p = new(DefinedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_definedValue
	return p
}

func (*DefinedValueContext) IsDefinedValueContext() {}

func NewDefinedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedValueContext {
	var p = new(DefinedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_definedValue

	return p
}

func (s *DefinedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedValueContext) ParameterizedValue() IParameterizedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterizedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterizedValueContext)
}

func (s *DefinedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterDefinedValue(s)
	}
}

func (s *DefinedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitDefinedValue(s)
	}
}

func (s *DefinedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitDefinedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) DefinedValue() (localctx IDefinedValueContext) {
	localctx = NewDefinedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, ASNParserRULE_definedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1083)
		p.ParameterizedValue()
	}

	return localctx
}

// IParameterizedValueContext is an interface to support dynamic dispatch.
type IParameterizedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterizedValueContext differentiates from other interfaces.
	IsParameterizedValueContext()
}

type ParameterizedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterizedValueContext() *ParameterizedValueContext {
	var p = new(ParameterizedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_parameterizedValue
	return p
}

func (*ParameterizedValueContext) IsParameterizedValueContext() {}

func NewParameterizedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterizedValueContext {
	var p = new(ParameterizedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_parameterizedValue

	return p
}

func (s *ParameterizedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterizedValueContext) SimpleDefinedValue() ISimpleDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleDefinedValueContext)
}

func (s *ParameterizedValueContext) ActualParameterList() IActualParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualParameterListContext)
}

func (s *ParameterizedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterizedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterizedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterParameterizedValue(s)
	}
}

func (s *ParameterizedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitParameterizedValue(s)
	}
}

func (s *ParameterizedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitParameterizedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ParameterizedValue() (localctx IParameterizedValueContext) {
	localctx = NewParameterizedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, ASNParserRULE_parameterizedValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.SimpleDefinedValue()
	}
	p.SetState(1087)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserL_BRACE {
		{
			p.SetState(1086)
			p.ActualParameterList()
		}

	}

	return localctx
}

// ISimpleDefinedValueContext is an interface to support dynamic dispatch.
type ISimpleDefinedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleDefinedValueContext differentiates from other interfaces.
	IsSimpleDefinedValueContext()
}

type SimpleDefinedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleDefinedValueContext() *SimpleDefinedValueContext {
	var p = new(SimpleDefinedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_simpleDefinedValue
	return p
}

func (*SimpleDefinedValueContext) IsSimpleDefinedValueContext() {}

func NewSimpleDefinedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDefinedValueContext {
	var p = new(SimpleDefinedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_simpleDefinedValue

	return p
}

func (s *SimpleDefinedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDefinedValueContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *SimpleDefinedValueContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *SimpleDefinedValueContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *SimpleDefinedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDefinedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDefinedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterSimpleDefinedValue(s)
	}
}

func (s *SimpleDefinedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitSimpleDefinedValue(s)
	}
}

func (s *SimpleDefinedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitSimpleDefinedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) SimpleDefinedValue() (localctx ISimpleDefinedValueContext) {
	localctx = NewSimpleDefinedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, ASNParserRULE_simpleDefinedValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1089)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(1092)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserDOT {
		{
			p.SetState(1090)
			p.Match(ASNParserDOT)
		}
		{
			p.SetState(1091)
			p.Match(ASNParserIDENTIFIER)
		}

	}

	return localctx
}

// IActualParameterListContext is an interface to support dynamic dispatch.
type IActualParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualParameterListContext differentiates from other interfaces.
	IsActualParameterListContext()
}

type ActualParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterListContext() *ActualParameterListContext {
	var p = new(ActualParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_actualParameterList
	return p
}

func (*ActualParameterListContext) IsActualParameterListContext() {}

func NewActualParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterListContext {
	var p = new(ActualParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_actualParameterList

	return p
}

func (s *ActualParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterListContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *ActualParameterListContext) AllActualParameter() []IActualParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IActualParameterContext)(nil)).Elem())
	var tst = make([]IActualParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IActualParameterContext)
		}
	}

	return tst
}

func (s *ActualParameterListContext) ActualParameter(i int) IActualParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IActualParameterContext)
}

func (s *ActualParameterListContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *ActualParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ActualParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ActualParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterActualParameterList(s)
	}
}

func (s *ActualParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitActualParameterList(s)
	}
}

func (s *ActualParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitActualParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ActualParameterList() (localctx IActualParameterListContext) {
	localctx = NewActualParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, ASNParserRULE_actualParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.Match(ASNParserL_BRACE)
	}
	{
		p.SetState(1095)
		p.ActualParameter()
	}
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(1096)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1097)
			p.ActualParameter()
		}

		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1103)
		p.Match(ASNParserR_BRACE)
	}

	return localctx
}

// IActualParameterContext is an interface to support dynamic dispatch.
type IActualParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualParameterContext differentiates from other interfaces.
	IsActualParameterContext()
}

type ActualParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterContext() *ActualParameterContext {
	var p = new(ActualParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_actualParameter
	return p
}

func (*ActualParameterContext) IsActualParameterContext() {}

func NewActualParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterContext {
	var p = new(ActualParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_actualParameter

	return p
}

func (s *ActualParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ActualParameterContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ActualParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterActualParameter(s)
	}
}

func (s *ActualParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitActualParameter(s)
	}
}

func (s *ActualParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitActualParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ActualParameter() (localctx IActualParameterContext) {
	localctx = NewActualParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, ASNParserRULE_actualParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1105)
			p.AsnType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1106)
			p.Value()
		}

	}

	return localctx
}

// IExceptionSpecContext is an interface to support dynamic dispatch.
type IExceptionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExceptionSpecContext differentiates from other interfaces.
	IsExceptionSpecContext()
}

type ExceptionSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionSpecContext() *ExceptionSpecContext {
	var p = new(ExceptionSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_exceptionSpec
	return p
}

func (*ExceptionSpecContext) IsExceptionSpecContext() {}

func NewExceptionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionSpecContext {
	var p = new(ExceptionSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_exceptionSpec

	return p
}

func (s *ExceptionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionSpecContext) EXCLAM() antlr.TerminalNode {
	return s.GetToken(ASNParserEXCLAM, 0)
}

func (s *ExceptionSpecContext) ExceptionIdentification() IExceptionIdentificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionIdentificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionIdentificationContext)
}

func (s *ExceptionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExceptionSpec(s)
	}
}

func (s *ExceptionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExceptionSpec(s)
	}
}

func (s *ExceptionSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExceptionSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExceptionSpec() (localctx IExceptionSpecContext) {
	localctx = NewExceptionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, ASNParserRULE_exceptionSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1109)
		p.Match(ASNParserEXCLAM)
	}
	{
		p.SetState(1110)
		p.ExceptionIdentification()
	}

	return localctx
}

// IExceptionIdentificationContext is an interface to support dynamic dispatch.
type IExceptionIdentificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExceptionIdentificationContext differentiates from other interfaces.
	IsExceptionIdentificationContext()
}

type ExceptionIdentificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionIdentificationContext() *ExceptionIdentificationContext {
	var p = new(ExceptionIdentificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_exceptionIdentification
	return p
}

func (*ExceptionIdentificationContext) IsExceptionIdentificationContext() {}

func NewExceptionIdentificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionIdentificationContext {
	var p = new(ExceptionIdentificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_exceptionIdentification

	return p
}

func (s *ExceptionIdentificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionIdentificationContext) SignedNumber() ISignedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *ExceptionIdentificationContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *ExceptionIdentificationContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ExceptionIdentificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASNParserCOLON, 0)
}

func (s *ExceptionIdentificationContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ExceptionIdentificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionIdentificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionIdentificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterExceptionIdentification(s)
	}
}

func (s *ExceptionIdentificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitExceptionIdentification(s)
	}
}

func (s *ExceptionIdentificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitExceptionIdentification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ExceptionIdentification() (localctx IExceptionIdentificationContext) {
	localctx = NewExceptionIdentificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, ASNParserRULE_exceptionIdentification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1112)
			p.SignedNumber()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1113)
			p.DefinedValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1114)
			p.AsnType()
		}
		{
			p.SetState(1115)
			p.Match(ASNParserCOLON)
		}
		{
			p.SetState(1116)
			p.Value()
		}

	}

	return localctx
}

// IAdditionalEnumerationContext is an interface to support dynamic dispatch.
type IAdditionalEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditionalEnumerationContext differentiates from other interfaces.
	IsAdditionalEnumerationContext()
}

type AdditionalEnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditionalEnumerationContext() *AdditionalEnumerationContext {
	var p = new(AdditionalEnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_additionalEnumeration
	return p
}

func (*AdditionalEnumerationContext) IsAdditionalEnumerationContext() {}

func NewAdditionalEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditionalEnumerationContext {
	var p = new(AdditionalEnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_additionalEnumeration

	return p
}

func (s *AdditionalEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditionalEnumerationContext) Enumeration() IEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerationContext)
}

func (s *AdditionalEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionalEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditionalEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAdditionalEnumeration(s)
	}
}

func (s *AdditionalEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAdditionalEnumeration(s)
	}
}

func (s *AdditionalEnumerationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitAdditionalEnumeration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) AdditionalEnumeration() (localctx IAdditionalEnumerationContext) {
	localctx = NewAdditionalEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, ASNParserRULE_additionalEnumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1120)
		p.Enumeration()
	}

	return localctx
}

// IIntegerTypeContext is an interface to support dynamic dispatch.
type IIntegerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerTypeContext differentiates from other interfaces.
	IsIntegerTypeContext()
}

type IntegerTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerTypeContext() *IntegerTypeContext {
	var p = new(IntegerTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_integerType
	return p
}

func (*IntegerTypeContext) IsIntegerTypeContext() {}

func NewIntegerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerTypeContext {
	var p = new(IntegerTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_integerType

	return p
}

func (s *IntegerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerTypeContext) INTEGER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserINTEGER_LITERAL, 0)
}

func (s *IntegerTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *IntegerTypeContext) NamedNumberList() INamedNumberListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedNumberListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedNumberListContext)
}

func (s *IntegerTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *IntegerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterIntegerType(s)
	}
}

func (s *IntegerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitIntegerType(s)
	}
}

func (s *IntegerTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitIntegerType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) IntegerType() (localctx IIntegerTypeContext) {
	localctx = NewIntegerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, ASNParserRULE_integerType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1122)
		p.Match(ASNParserINTEGER_LITERAL)
	}
	p.SetState(1127)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1123)
			p.Match(ASNParserL_BRACE)
		}
		{
			p.SetState(1124)
			p.NamedNumberList()
		}
		{
			p.SetState(1125)
			p.Match(ASNParserR_BRACE)
		}

	}

	return localctx
}

// INamedNumberListContext is an interface to support dynamic dispatch.
type INamedNumberListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedNumberListContext differentiates from other interfaces.
	IsNamedNumberListContext()
}

type NamedNumberListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedNumberListContext() *NamedNumberListContext {
	var p = new(NamedNumberListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_namedNumberList
	return p
}

func (*NamedNumberListContext) IsNamedNumberListContext() {}

func NewNamedNumberListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedNumberListContext {
	var p = new(NamedNumberListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_namedNumberList

	return p
}

func (s *NamedNumberListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedNumberListContext) AllNamedNumber() []INamedNumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedNumberContext)(nil)).Elem())
	var tst = make([]INamedNumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedNumberContext)
		}
	}

	return tst
}

func (s *NamedNumberListContext) NamedNumber(i int) INamedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedNumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedNumberContext)
}

func (s *NamedNumberListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *NamedNumberListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *NamedNumberListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedNumberListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedNumberListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterNamedNumberList(s)
	}
}

func (s *NamedNumberListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitNamedNumberList(s)
	}
}

func (s *NamedNumberListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitNamedNumberList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) NamedNumberList() (localctx INamedNumberListContext) {
	localctx = NewNamedNumberListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, ASNParserRULE_namedNumberList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1129)
		p.NamedNumber()
	}

	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(1130)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1131)
			p.NamedNumber()
		}

		p.SetState(1136)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObjectidentifiertypeContext is an interface to support dynamic dispatch.
type IObjectidentifiertypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectidentifiertypeContext differentiates from other interfaces.
	IsObjectidentifiertypeContext()
}

type ObjectidentifiertypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectidentifiertypeContext() *ObjectidentifiertypeContext {
	var p = new(ObjectidentifiertypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_objectidentifiertype
	return p
}

func (*ObjectidentifiertypeContext) IsObjectidentifiertypeContext() {}

func NewObjectidentifiertypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectidentifiertypeContext {
	var p = new(ObjectidentifiertypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_objectidentifiertype

	return p
}

func (s *ObjectidentifiertypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectidentifiertypeContext) OBJECT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOBJECT_LITERAL, 0)
}

func (s *ObjectidentifiertypeContext) IDENTIFIER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER_LITERAL, 0)
}

func (s *ObjectidentifiertypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectidentifiertypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectidentifiertypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterObjectidentifiertype(s)
	}
}

func (s *ObjectidentifiertypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitObjectidentifiertype(s)
	}
}

func (s *ObjectidentifiertypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitObjectidentifiertype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Objectidentifiertype() (localctx IObjectidentifiertypeContext) {
	localctx = NewObjectidentifiertypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, ASNParserRULE_objectidentifiertype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		p.Match(ASNParserOBJECT_LITERAL)
	}
	{
		p.SetState(1138)
		p.Match(ASNParserIDENTIFIER_LITERAL)
	}

	return localctx
}

// IComponentRelationConstraintContext is an interface to support dynamic dispatch.
type IComponentRelationConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentRelationConstraintContext differentiates from other interfaces.
	IsComponentRelationConstraintContext()
}

type ComponentRelationConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentRelationConstraintContext() *ComponentRelationConstraintContext {
	var p = new(ComponentRelationConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentRelationConstraint
	return p
}

func (*ComponentRelationConstraintContext) IsComponentRelationConstraintContext() {}

func NewComponentRelationConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentRelationConstraintContext {
	var p = new(ComponentRelationConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentRelationConstraint

	return p
}

func (s *ComponentRelationConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentRelationConstraintContext) AllL_BRACE() []antlr.TerminalNode {
	return s.GetTokens(ASNParserL_BRACE)
}

func (s *ComponentRelationConstraintContext) L_BRACE(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, i)
}

func (s *ComponentRelationConstraintContext) AllR_BRACE() []antlr.TerminalNode {
	return s.GetTokens(ASNParserR_BRACE)
}

func (s *ComponentRelationConstraintContext) R_BRACE(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, i)
}

func (s *ComponentRelationConstraintContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *ComponentRelationConstraintContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *ComponentRelationConstraintContext) AllAtNotation() []IAtNotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtNotationContext)(nil)).Elem())
	var tst = make([]IAtNotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtNotationContext)
		}
	}

	return tst
}

func (s *ComponentRelationConstraintContext) AtNotation(i int) IAtNotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtNotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtNotationContext)
}

func (s *ComponentRelationConstraintContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *ComponentRelationConstraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *ComponentRelationConstraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *ComponentRelationConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentRelationConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentRelationConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentRelationConstraint(s)
	}
}

func (s *ComponentRelationConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentRelationConstraint(s)
	}
}

func (s *ComponentRelationConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitComponentRelationConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ComponentRelationConstraint() (localctx IComponentRelationConstraintContext) {
	localctx = NewComponentRelationConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, ASNParserRULE_componentRelationConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1140)
		p.Match(ASNParserL_BRACE)
	}

	{
		p.SetState(1141)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(1144)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserDOT {
		{
			p.SetState(1142)
			p.Match(ASNParserDOT)
		}
		{
			p.SetState(1143)
			p.Match(ASNParserIDENTIFIER)
		}

	}

	{
		p.SetState(1146)
		p.Match(ASNParserR_BRACE)
	}
	p.SetState(1158)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserL_BRACE {
		{
			p.SetState(1147)
			p.Match(ASNParserL_BRACE)
		}
		{
			p.SetState(1148)
			p.AtNotation()
		}
		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ASNParserCOMMA {
			{
				p.SetState(1149)
				p.Match(ASNParserCOMMA)
			}
			{
				p.SetState(1150)
				p.AtNotation()
			}

			p.SetState(1155)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1156)
			p.Match(ASNParserR_BRACE)
		}

	}

	return localctx
}

// IAtNotationContext is an interface to support dynamic dispatch.
type IAtNotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtNotationContext differentiates from other interfaces.
	IsAtNotationContext()
}

type AtNotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtNotationContext() *AtNotationContext {
	var p = new(AtNotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_atNotation
	return p
}

func (*AtNotationContext) IsAtNotationContext() {}

func NewAtNotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtNotationContext {
	var p = new(AtNotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_atNotation

	return p
}

func (s *AtNotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AtNotationContext) ComponentIdList() IComponentIdListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentIdListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentIdListContext)
}

func (s *AtNotationContext) A_ROND() antlr.TerminalNode {
	return s.GetToken(ASNParserA_ROND, 0)
}

func (s *AtNotationContext) A_ROND_DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserA_ROND_DOT, 0)
}

func (s *AtNotationContext) Level() ILevelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelContext)
}

func (s *AtNotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtNotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtNotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterAtNotation(s)
	}
}

func (s *AtNotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitAtNotation(s)
	}
}

func (s *AtNotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitAtNotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) AtNotation() (localctx IAtNotationContext) {
	localctx = NewAtNotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, ASNParserRULE_atNotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserA_ROND:
		{
			p.SetState(1160)
			p.Match(ASNParserA_ROND)
		}

	case ASNParserA_ROND_DOT:
		{
			p.SetState(1161)
			p.Match(ASNParserA_ROND_DOT)
		}
		{
			p.SetState(1162)
			p.Level()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1165)
		p.ComponentIdList()
	}

	return localctx
}

// ILevelContext is an interface to support dynamic dispatch.
type ILevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLevelContext differentiates from other interfaces.
	IsLevelContext()
}

type LevelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelContext() *LevelContext {
	var p = new(LevelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_level
	return p
}

func (*LevelContext) IsLevelContext() {}

func NewLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelContext {
	var p = new(LevelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_level

	return p
}

func (s *LevelContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, 0)
}

func (s *LevelContext) Level() ILevelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelContext)
}

func (s *LevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterLevel(s)
	}
}

func (s *LevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitLevel(s)
	}
}

func (s *LevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) Level() (localctx ILevelContext) {
	localctx = NewLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, ASNParserRULE_level)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASNParserDOT {
		{
			p.SetState(1167)
			p.Match(ASNParserDOT)
		}
		{
			p.SetState(1168)
			p.Level()
		}

	}

	return localctx
}

// IComponentIdListContext is an interface to support dynamic dispatch.
type IComponentIdListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentIdListContext differentiates from other interfaces.
	IsComponentIdListContext()
}

type ComponentIdListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentIdListContext() *ComponentIdListContext {
	var p = new(ComponentIdListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_componentIdList
	return p
}

func (*ComponentIdListContext) IsComponentIdListContext() {}

func NewComponentIdListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentIdListContext {
	var p = new(ComponentIdListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_componentIdList

	return p
}

func (s *ComponentIdListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentIdListContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASNParserIDENTIFIER)
}

func (s *ComponentIdListContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, i)
}

func (s *ComponentIdListContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ASNParserDOT)
}

func (s *ComponentIdListContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserDOT, i)
}

func (s *ComponentIdListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentIdListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentIdListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterComponentIdList(s)
	}
}

func (s *ComponentIdListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitComponentIdList(s)
	}
}

func (s *ComponentIdListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitComponentIdList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) ComponentIdList() (localctx IComponentIdListContext) {
	localctx = NewComponentIdListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, ASNParserRULE_componentIdList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1171)
		p.Match(ASNParserIDENTIFIER)
	}
	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserDOT {
		{
			p.SetState(1172)
			p.Match(ASNParserDOT)
		}
		{
			p.SetState(1173)
			p.Match(ASNParserIDENTIFIER)
		}

		p.SetState(1178)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOctetStringTypeContext is an interface to support dynamic dispatch.
type IOctetStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctetStringTypeContext differentiates from other interfaces.
	IsOctetStringTypeContext()
}

type OctetStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctetStringTypeContext() *OctetStringTypeContext {
	var p = new(OctetStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_octetStringType
	return p
}

func (*OctetStringTypeContext) IsOctetStringTypeContext() {}

func NewOctetStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OctetStringTypeContext {
	var p = new(OctetStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_octetStringType

	return p
}

func (s *OctetStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OctetStringTypeContext) OCTET_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserOCTET_LITERAL, 0)
}

func (s *OctetStringTypeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSTRING_LITERAL, 0)
}

func (s *OctetStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OctetStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OctetStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterOctetStringType(s)
	}
}

func (s *OctetStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitOctetStringType(s)
	}
}

func (s *OctetStringTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitOctetStringType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) OctetStringType() (localctx IOctetStringTypeContext) {
	localctx = NewOctetStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, ASNParserRULE_octetStringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1179)
		p.Match(ASNParserOCTET_LITERAL)
	}
	{
		p.SetState(1180)
		p.Match(ASNParserSTRING_LITERAL)
	}

	return localctx
}

// IBitStringTypeContext is an interface to support dynamic dispatch.
type IBitStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitStringTypeContext differentiates from other interfaces.
	IsBitStringTypeContext()
}

type BitStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitStringTypeContext() *BitStringTypeContext {
	var p = new(BitStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_bitStringType
	return p
}

func (*BitStringTypeContext) IsBitStringTypeContext() {}

func NewBitStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitStringTypeContext {
	var p = new(BitStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_bitStringType

	return p
}

func (s *BitStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BitStringTypeContext) BIT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserBIT_LITERAL, 0)
}

func (s *BitStringTypeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserSTRING_LITERAL, 0)
}

func (s *BitStringTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserL_BRACE, 0)
}

func (s *BitStringTypeContext) NamedBitList() INamedBitListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedBitListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedBitListContext)
}

func (s *BitStringTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASNParserR_BRACE, 0)
}

func (s *BitStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterBitStringType(s)
	}
}

func (s *BitStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitBitStringType(s)
	}
}

func (s *BitStringTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitBitStringType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) BitStringType() (localctx IBitStringTypeContext) {
	localctx = NewBitStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, ASNParserRULE_bitStringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1182)
		p.Match(ASNParserBIT_LITERAL)
	}
	{
		p.SetState(1183)
		p.Match(ASNParserSTRING_LITERAL)
	}

	p.SetState(1189)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1185)
			p.Match(ASNParserL_BRACE)
		}
		{
			p.SetState(1186)
			p.NamedBitList()
		}
		{
			p.SetState(1187)
			p.Match(ASNParserR_BRACE)
		}

	}

	return localctx
}

// INamedBitListContext is an interface to support dynamic dispatch.
type INamedBitListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedBitListContext differentiates from other interfaces.
	IsNamedBitListContext()
}

type NamedBitListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedBitListContext() *NamedBitListContext {
	var p = new(NamedBitListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_namedBitList
	return p
}

func (*NamedBitListContext) IsNamedBitListContext() {}

func NewNamedBitListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedBitListContext {
	var p = new(NamedBitListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_namedBitList

	return p
}

func (s *NamedBitListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedBitListContext) AllNamedBit() []INamedBitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedBitContext)(nil)).Elem())
	var tst = make([]INamedBitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedBitContext)
		}
	}

	return tst
}

func (s *NamedBitListContext) NamedBit(i int) INamedBitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedBitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedBitContext)
}

func (s *NamedBitListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASNParserCOMMA)
}

func (s *NamedBitListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASNParserCOMMA, i)
}

func (s *NamedBitListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedBitListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedBitListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterNamedBitList(s)
	}
}

func (s *NamedBitListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitNamedBitList(s)
	}
}

func (s *NamedBitListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitNamedBitList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) NamedBitList() (localctx INamedBitListContext) {
	localctx = NewNamedBitListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, ASNParserRULE_namedBitList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1191)
		p.NamedBit()
	}

	p.SetState(1196)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASNParserCOMMA {
		{
			p.SetState(1192)
			p.Match(ASNParserCOMMA)
		}
		{
			p.SetState(1193)
			p.NamedBit()
		}

		p.SetState(1198)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INamedBitContext is an interface to support dynamic dispatch.
type INamedBitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedBitContext differentiates from other interfaces.
	IsNamedBitContext()
}

type NamedBitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedBitContext() *NamedBitContext {
	var p = new(NamedBitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_namedBit
	return p
}

func (*NamedBitContext) IsNamedBitContext() {}

func NewNamedBitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedBitContext {
	var p = new(NamedBitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_namedBit

	return p
}

func (s *NamedBitContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedBitContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASNParserIDENTIFIER, 0)
}

func (s *NamedBitContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserL_PARAN, 0)
}

func (s *NamedBitContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASNParserR_PARAN, 0)
}

func (s *NamedBitContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASNParserNUMBER, 0)
}

func (s *NamedBitContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *NamedBitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedBitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedBitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterNamedBit(s)
	}
}

func (s *NamedBitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitNamedBit(s)
	}
}

func (s *NamedBitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitNamedBit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) NamedBit() (localctx INamedBitContext) {
	localctx = NewNamedBitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, ASNParserRULE_namedBit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1199)
		p.Match(ASNParserIDENTIFIER)
	}
	{
		p.SetState(1200)
		p.Match(ASNParserL_PARAN)
	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASNParserNUMBER:
		{
			p.SetState(1201)
			p.Match(ASNParserNUMBER)
		}

	case ASNParserIDENTIFIER:
		{
			p.SetState(1202)
			p.DefinedValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1205)
		p.Match(ASNParserR_PARAN)
	}

	return localctx
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASNParserRULE_booleanValue
	return p
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASNParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserTRUE_LITERAL, 0)
}

func (s *BooleanValueContext) FALSE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserFALSE_LITERAL, 0)
}

func (s *BooleanValueContext) TRUE_SMALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserTRUE_SMALL_LITERAL, 0)
}

func (s *BooleanValueContext) FALSE_SMALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASNParserFALSE_SMALL_LITERAL, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASNListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ASNVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ASNParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, ASNParserRULE_booleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1207)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASNParserTRUE_LITERAL)|(1<<ASNParserFALSE_LITERAL)|(1<<ASNParserTRUE_SMALL_LITERAL)|(1<<ASNParserFALSE_SMALL_LITERAL))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
